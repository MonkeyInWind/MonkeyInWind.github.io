<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>花瓣飘落效果</title>
    <url>/post/petalsFluttered/</url>
    <content><![CDATA[<p>先上效果：<a href="https://monkeyinwind.github.io/canvaspetal/index.html" target="_blank" rel="noopener">https://monkeyinwind.github.io/canvaspetal/index.html</a><br>github：<a href="https://github.com/MonkeyInWind/canvaspetal" target="_blank" rel="noopener">https://github.com/MonkeyInWind/canvaspetal</a></p>
<a id="more"></a>
<p>这个demo写了很久了，今天有时间简单写一下过程。<br>用了react，这个不重要，随便用什么环境都可以。<br>首先花瓣要有素材，随便搜了一下，切了几个出来。</p>
<p><img src="1.png" alt="image.png"></p>
<h1 id="1、在页面上添加一个canvas"><a href="#1、在页面上添加一个canvas" class="headerlink" title="1、在页面上添加一个canvas"></a>1、在页面上添加一个canvas</h1><p>整个页面只有一个canvas，我们需要这个canvas占满整个浏览器可视区，并且在浏览器窗口改变大小的时候依然和可视区大小相同，同时给canvas加个背景色。<br><img src="2.png" alt="image.png"><br>这一步很简单没有什么需要说的。</p>
<h1 id="2、在canvas上画一个花瓣"><a href="#2、在canvas上画一个花瓣" class="headerlink" title="2、在canvas上画一个花瓣"></a>2、在canvas上画一个花瓣</h1><p>创建一个<code>createPetal</code>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.src = require(&quot;./images/petal1.png&quot;);</span><br><span class="line">    img.onload = () =&gt; &#123;</span><br><span class="line">      ctx.drawImage(img, 100, 100);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>componentDidMount</code>调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    this.setCanvas();</span><br><span class="line">    window.onresize = this.setCanvas;</span><br><span class="line">    this.createPetal();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这样就在<code>100， 100</code>这个位置画了个花瓣<br><img src="3.png" alt="image.png"></p>
<h1 id="3、让这个花瓣动起来"><a href="#3、让这个花瓣动起来" class="headerlink" title="3、让这个花瓣动起来"></a>3、让这个花瓣动起来</h1><p>canvas动画是高频率刷新，清空上一帧，画下一帧，看起来是动画。<br>了解了动画的原理，接下来就可以开始写动画，首先将坐标放到<code>state</code>中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0,</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建一个<code>go</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go(ctx, img) &#123;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: this.state.x + 1,</span><br><span class="line">      y: this.state.y + 1</span><br><span class="line">    &#125;);//移动花瓣坐标</span><br><span class="line">    ctx.drawImage(img, this.state.x, this.state.y);</span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>createPetal</code>中调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.src = require(&quot;./images/petal1.png&quot;);</span><br><span class="line">    img.onload = () =&gt; &#123;</span><br><span class="line">      ctx.drawImage(img, this.state.x, this.state.y);</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接下来可以看到效果。<br><img src="4.gif" alt="Feb-03-2019 10-16-19.gif"><br>录的有点卡，实际上要比这个效果好很多。。。<br>有没有发现问题，花瓣位置超出浏览器之后去哪了打印一下坐标。<br><img src="5.png" alt="image.png"><br>可以看到还在继续飘，这不是想要的，所以在坐标超出浏览器之后让它回到初始位置。<br><code>go</code>这个函数修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go(ctx, img) &#123;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    let x = this.state.x + 1;</span><br><span class="line">    let y = this.state.y + 1;</span><br><span class="line">    if (x &gt; this.state.cw || y &gt; this.state.ch) &#123;</span><br><span class="line">      x = 0;</span><br><span class="line">      y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x,</span><br><span class="line">      y</span><br><span class="line">    &#125;);//移动花瓣坐标</span><br><span class="line">    ctx.drawImage(img, this.state.x, this.state.y);</span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>看一下效果<br><img src="6.gif" alt="Feb-03-2019 10-24-14.gif"></p>
<p>这一步实现之后，有没有发现还有问题，要模拟自然飘落，这个花瓣不可能没有旋转，接下来再加上旋转。<br>这个旋转，需要的是画布旋转，旋转画好了之后再复位。<br>在<code>state</code>中加上旋转角度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0,</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">      r: 0   //旋转角度</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>go</code>里面加上旋转，并且为了统一动作和计算方便，这里将图片位移改为画布位移，画图坐标相对画布始终在同一位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go(ctx, img) &#123;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    let x = this.state.x + 1;</span><br><span class="line">    let y = this.state.y + 1;</span><br><span class="line">    let r = this.state.r + 0.1;</span><br><span class="line">    if (x &gt; this.state.cw || y &gt; this.state.ch) &#123;</span><br><span class="line">      x = 0;</span><br><span class="line">      y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x,</span><br><span class="line">      y,</span><br><span class="line">      r</span><br><span class="line">    &#125;);//移动花瓣坐标</span><br><span class="line">    ctx.save();//保存画布当前状态</span><br><span class="line">    ctx.translate(this.state.x, this.state.y); //改为画布位移</span><br><span class="line">    ctx.rotate(this.state.r);   //画布旋转</span><br><span class="line">    ctx.drawImage(img, 0, 0);  //画图坐标始终在画布左上角</span><br><span class="line">    ctx.restore();</span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="7.gif" alt="Feb-03-2019 10-48-19.gif"><br>和预想的不太一样，这是因为画布默认的旋转中心为左上角，<br>我们需要将旋转中心移到图片的中心。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go(ctx, img) &#123;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    let w = img.width;</span><br><span class="line">    let h = img.height;</span><br><span class="line">    let x = this.state.x + 1;</span><br><span class="line">    let y = this.state.y + 1;</span><br><span class="line">    let r = this.state.r + 0.1;</span><br><span class="line">    if (x &gt; this.state.cw || y &gt; this.state.ch) &#123;</span><br><span class="line">      x = 0;</span><br><span class="line">      y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x,</span><br><span class="line">      y,</span><br><span class="line">      r</span><br><span class="line">    &#125;);//移动花瓣坐标</span><br><span class="line">    ctx.save();//保存画布当前状态</span><br><span class="line">    ctx.translate(this.state.x + w / 2, this.state.y + h / 2); //改为画布位移</span><br><span class="line">    ctx.rotate(this.state.r);</span><br><span class="line">    ctx.drawImage(img, -w / 2, - h / 2);  //画图坐标始终在画布左上角</span><br><span class="line">    ctx.restore();</span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>看一下效果<br><img src="8.gif" alt="Feb-03-2019 10-55-18.gif"><br>旋转是有了，<br>但是好像不太对，只绕Z轴旋转，要让它变成3D旋转，这里要用到缩放<code>scale</code>，缩放这里不可能一直放大或者缩小，所以还要加一个变量控制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0,</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">      r: 0,</span><br><span class="line">      scale: 1,</span><br><span class="line">      toLarge: true</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来将<code>go</code>改一下，加上<code>scale</code>并且旋转速度调整一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go(ctx, img) &#123;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    let w = img.width;</span><br><span class="line">    let h = img.height;</span><br><span class="line">    let x = this.state.x + 1;</span><br><span class="line">    let y = this.state.y + 1;</span><br><span class="line">    let r = this.state.r + 0.05;</span><br><span class="line">    let scale = this.state.scale;</span><br><span class="line">    let toLarge = this.state.toLarge;</span><br><span class="line"></span><br><span class="line">    if (scale &gt;= 1) &#123;</span><br><span class="line">      toLarge = false;</span><br><span class="line">    &#125; else if (scale &lt;= 0) &#123;</span><br><span class="line">      toLarge = true;</span><br><span class="line">    &#125;//这里根据scale大小设置toLarge</span><br><span class="line"></span><br><span class="line">    if (toLarge) &#123;</span><br><span class="line">      scale += 0.01;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      scale -= 0.01;</span><br><span class="line">    &#125;//这里根据toLarge更改scale值</span><br><span class="line">    if (x &gt; this.state.cw || y &gt; this.state.ch) &#123;</span><br><span class="line">      x = 0;</span><br><span class="line">      y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x,</span><br><span class="line">      y,</span><br><span class="line">      r,</span><br><span class="line">      scale,</span><br><span class="line">      toLarge</span><br><span class="line">    &#125;);//移动花瓣坐标</span><br><span class="line">    ctx.save();//保存画布当前状态</span><br><span class="line">    ctx.translate(this.state.x + w / 2, this.state.y + h / 2); //改为画布位移</span><br><span class="line">    ctx.rotate(this.state.r);</span><br><span class="line">    ctx.scale(1, this.state.scale);</span><br><span class="line">    ctx.drawImage(img, -w / 2, - h / 2);  //画图坐标始终在画布左上角</span><br><span class="line">    ctx.restore();</span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>看一下效果<br><img src="9.gif" alt="Feb-03-2019 11-13-14.gif"><br>至此一个花瓣就写完了。<br>但是我们想要的是很多个花瓣同时飘。<br>这就需要一个花瓣的类。</p>
<h1 id="4、创建一个花瓣的class"><a href="#4、创建一个花瓣的class" class="headerlink" title="4、创建一个花瓣的class"></a>4、创建一个花瓣的class</h1><p>新建一个<code>petal.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Petal &#123;</span><br><span class="line">  constructor(w, h) &#123;</span><br><span class="line">    this.canvasW = w;  //canvas宽</span><br><span class="line">    this.canvasH = h;  //canvas高</span><br><span class="line">    this.w = 0;        //花瓣宽</span><br><span class="line">    this.h = 0;        //花瓣高</span><br><span class="line">    this.x = 0;        //初始x坐标</span><br><span class="line">    this.y = 0;        //初始y坐标</span><br><span class="line">    this.r = 0;        //初始旋转角度</span><br><span class="line">    this.scale = 1;    //初始缩放</span><br><span class="line">    this.toLarge = false;   //默认放大为false</span><br><span class="line">    this.speedX = 1;   //x方向速度</span><br><span class="line">    this.speedY = 1;   //y方向速度</span><br><span class="line">    this.speedScale= 0.01  //缩放速度</span><br><span class="line">    this.speedR = 0.05    //旋转速度</span><br><span class="line">  &#125;</span><br><span class="line">  //数据初始化，用于当花瓣超出浏览器可视区时重置位置</span><br><span class="line">  init() &#123;</span><br><span class="line">    this.x = 0;</span><br><span class="line">    this.y = 0;</span><br><span class="line">    this.r = 0;</span><br><span class="line">    this.scale = 1;</span><br><span class="line">    this.speedX = 1;</span><br><span class="line">    this.speedY = 1;</span><br><span class="line">    this.speedScale = 0.01;</span><br><span class="line">    this.speedR = 0.05;</span><br><span class="line">  &#125;</span><br><span class="line">  //画布位移、画图、画布复位</span><br><span class="line">  draw(ctx, img) &#123;</span><br><span class="line">    this.w = img.width;</span><br><span class="line">    this.h = img.height;</span><br><span class="line">    ctx.save();     //保存当前画布状态</span><br><span class="line">    ctx.translate(this.x + this.w / 2,  this.y + this.h / 2);  //画布位移</span><br><span class="line">    ctx.rotate(this.r);   //画布旋转</span><br><span class="line">    ctx.scale(1, this.scale);  //画布缩放</span><br><span class="line">    ctx.drawImage(img, -this.w / 2, -this.h / 2);   //画图</span><br><span class="line">    ctx.restore();    //画布复位</span><br><span class="line">  &#125;</span><br><span class="line">  //计算坐标</span><br><span class="line">  move() &#123;</span><br><span class="line">    this.x += this.speedX;</span><br><span class="line">    this.y += this.speedY;</span><br><span class="line">    this.r += this.speedR;</span><br><span class="line">    if (this.scale &gt;= 1) &#123;</span><br><span class="line">      this.toLarge = false;</span><br><span class="line">    &#125; else if (this.scale &lt;= 0) &#123;</span><br><span class="line">      this.toLarge = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.toLarge) &#123;</span><br><span class="line">      this.scale += this.speedScale;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.scale -= this.speedScale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.x &gt;= this.canvasW || this.y &gt;= this.canvasH) &#123;</span><br><span class="line">      this.init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>App.js</code>内引入并new一个花瓣，打印一下；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import Petal from &apos;./petal&apos;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0,</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">      r: 0,</span><br><span class="line">      scale: 1,</span><br><span class="line">      toLarge: true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.setCanvas = this.setCanvas.bind(this);</span><br><span class="line">    this.componentDidMount = this.componentDidMount.bind(this);</span><br><span class="line">    this.createPetal = this.createPetal.bind(this);</span><br><span class="line">    this.go = this.go.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setCanvas() &#123;</span><br><span class="line">    let W = document.documentElement.clientWidth;</span><br><span class="line">    let H = document.documentElement.clientHeight;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      cw: W,</span><br><span class="line">      ch: H</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.src = require(&quot;./images/petal1.png&quot;);</span><br><span class="line">    img.onload = () =&gt; &#123;</span><br><span class="line">      //ctx.drawImage(img, this.state.x, this.state.y);</span><br><span class="line">      // this.go(ctx, img);</span><br><span class="line">      let petal = new Petal(this.state.cw, this.state.ch);</span><br><span class="line">      console.log(petal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(ctx, img) &#123;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    let w = img.width;</span><br><span class="line">    let h = img.height;</span><br><span class="line">    let x = this.state.x + 1;</span><br><span class="line">    let y = this.state.y + 1;</span><br><span class="line">    let r = this.state.r + 0.05;</span><br><span class="line">    let scale = this.state.scale;</span><br><span class="line">    let toLarge = this.state.toLarge;</span><br><span class="line"></span><br><span class="line">    if (scale &gt;= 1) &#123;</span><br><span class="line">      toLarge = false;</span><br><span class="line">    &#125; else if (scale &lt;= 0) &#123;</span><br><span class="line">      toLarge = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (toLarge) &#123;</span><br><span class="line">      scale += 0.01;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      scale -= 0.01;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &gt; this.state.cw || y &gt; this.state.ch) &#123;</span><br><span class="line">      x = 0;</span><br><span class="line">      y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x,</span><br><span class="line">      y,</span><br><span class="line">      r,</span><br><span class="line">      scale,</span><br><span class="line">      toLarge</span><br><span class="line">    &#125;);//移动花瓣坐标</span><br><span class="line">    ctx.save();//保存画布当前状态</span><br><span class="line">    ctx.translate(this.state.x + w / 2, this.state.y + h / 2); //改为画布位移</span><br><span class="line">    ctx.rotate(this.state.r);</span><br><span class="line">    ctx.scale(1, this.state.scale);</span><br><span class="line">    ctx.drawImage(img, -w / 2, - h / 2);  //画图坐标始终在画布左上角</span><br><span class="line">    ctx.restore();</span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.setCanvas();</span><br><span class="line">    window.onresize = this.setCanvas;</span><br><span class="line">    this.createPetal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;canvas id=&quot;canvas&quot; ref=&quot;canvas&quot; width=&#123;this.state.cw&#125; height=&#123;this.state.ch&#125;&gt;&lt;/canvas&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p><img src="10.png" alt="image.png"><br>可以看见已经创建了一个初始的花瓣，暂时还没有画图片。<br>接下来就是把之前的go改一下，画上花瓣并动起来。<br><code>App.js</code>更改后如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import Petal from &apos;./petal&apos;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.setCanvas = this.setCanvas.bind(this);</span><br><span class="line">    this.componentDidMount = this.componentDidMount.bind(this);</span><br><span class="line">    this.createPetal = this.createPetal.bind(this);</span><br><span class="line">    this.go = this.go.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setCanvas() &#123;</span><br><span class="line">    let W = document.documentElement.clientWidth;</span><br><span class="line">    let H = document.documentElement.clientHeight;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      cw: W,</span><br><span class="line">      ch: H</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.src = require(&quot;./images/petal1.png&quot;);</span><br><span class="line">    img.onload = () =&gt; &#123;</span><br><span class="line">      let petal = new Petal(this.state.cw, this.state.ch);</span><br><span class="line">      this.go(ctx, petal, img);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(ctx, petal, img) &#123;</span><br><span class="line">    let W = this.state.cw;</span><br><span class="line">    let H = this.state.ch;</span><br><span class="line">    //浏览器窗口改变大小时同步更新petal的cnavas宽高值，与花瓣坐标对比判断是否在可视区内</span><br><span class="line">    petal.canvasW = W;</span><br><span class="line">    petal.canvasH = H;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    petal.move();</span><br><span class="line">    petal.draw(ctx, img);</span><br><span class="line"></span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, petal, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.setCanvas();</span><br><span class="line">    window.onresize = this.setCanvas;</span><br><span class="line">    this.createPetal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;canvas id=&quot;canvas&quot; ref=&quot;canvas&quot; width=&#123;this.state.cw&#125; height=&#123;this.state.ch&#125;&gt;&lt;/canvas&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<h1 id="5、很多花瓣"><a href="#5、很多花瓣" class="headerlink" title="5、很多花瓣"></a>5、很多花瓣</h1><p>一个花瓣已经完成了，接下来就是很多个花瓣。<br>这里涉及到几个点：<br>1、img的src不能用变量，所以要用字符串拼接变量的形式。<br>2、一个花瓣用了onload，很多花瓣很明显一个onload已经不能满足了，这里用<code>promise.all</code>。<br>3、创建很多花瓣，并不是每次<code>drawImage</code>都需要<code>clearRect</code>，需要在第0个画之前清空canvas。<br>4、关于初始坐标和初始速度，很多个花瓣就需要随机坐标和随机速度，而且初始化所在的区域需要计算，否则会出现花瓣位移过程中不经过浏览器可视区或者分布不均。</p>
<h5 id="img的src"><a href="#img的src" class="headerlink" title="img的src"></a>img的src</h5><p>在<code>state</code>里加上花瓣数组，这里不能带后缀。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0,</span><br><span class="line">      n: 60,   //所要创建的花瓣数量</span><br><span class="line">      imgnames: [</span><br><span class="line">        &quot;petal1&quot;,</span><br><span class="line">        &quot;petal2&quot;,</span><br><span class="line">        &quot;petal3&quot;,</span><br><span class="line">        &quot;petal4&quot;,</span><br><span class="line">        &quot;petal5&quot;,</span><br><span class="line">        &quot;petal6&quot;,</span><br><span class="line">        &quot;petal7&quot;,</span><br><span class="line">        &quot;petal8&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>createPetal</code>函数改一下，创建多个img：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    // let img = new Image();</span><br><span class="line">    // img.src = require(&quot;./images/petal1.png&quot;);</span><br><span class="line">    let totalNum = this.state.imgnames.length; //图片的总数量</span><br><span class="line">    for (let i = 0; i &lt; this.state.n; i++) &#123;</span><br><span class="line">      let imgname = this.state.imgnames[i % totalNum];</span><br><span class="line">      let img = new Image();</span><br><span class="line">      img.src = require(`./images/$&#123;imgname&#125;.png`);</span><br><span class="line">      console.log(img)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // img.onload = () =&gt; &#123;</span><br><span class="line">      // let petal = new Petal(this.state.cw, this.state.ch);</span><br><span class="line">      // this.go(ctx, petal, img);</span><br><span class="line">    // &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>打印出60个img，src为base64；</p>
<h5 id="所有图片onload"><a href="#所有图片onload" class="headerlink" title="所有图片onload"></a>所有图片onload</h5><p>这里把单个img的load封装为<code>promise</code>，添加到一个数组里，然后用<code>promise.all</code><br>新建一个<code>imgLoad</code>函数，返回一个load的<code>promise</code>;<br>新建一个allImgLoad函数，用于返回一个<code>promise.all</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imgLoad(imgname) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        let img = new Image();</span><br><span class="line">        img.src = require(`./images/$&#123;imgname&#125;.png`);</span><br><span class="line">        img.onload = () =&gt; &#123;</span><br><span class="line">          resolve(img);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch(e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  allImgLoad(imgnames) &#123;</span><br><span class="line">    let p = [];</span><br><span class="line">    for(let i = 0; i &lt; imgnames.length; i++) &#123;</span><br><span class="line">      p.push(this.imgLoad(imgnames[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.all(p).then(res =&gt; &#123;</span><br><span class="line">      return res;</span><br><span class="line">    &#125;).catch((e) =&gt; &#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    // let img = new Image();</span><br><span class="line">    // img.src = require(&quot;./images/petal1.png&quot;);</span><br><span class="line">    let imgnames = [];</span><br><span class="line">    let totalNum = this.state.imgnames.length; //图片的总数量</span><br><span class="line">    for (let i = 0; i &lt; this.state.n; i++) &#123;</span><br><span class="line">      let imgname = this.state.imgnames[i % totalNum];</span><br><span class="line">      imgnames.push(imgname);</span><br><span class="line">    &#125;</span><br><span class="line">    let imgs = await this.allImgLoad(imgnames);</span><br><span class="line">    console.log(imgs)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到打印出了60个img<br><img src="11.png" alt="image.png"></p>
<h5 id="很多花瓣"><a href="#很多花瓣" class="headerlink" title="很多花瓣"></a>很多花瓣</h5><p>每一帧画60个花瓣，并且在第0个画之前清空画布，如果每画一个都清空一次，会把前59个都清空，画布上只有最后一个。<br>在<code>Petal</code>类里边的<code>move</code>和<code>init</code>用异步，加个<code>async</code>，否则会出现有的花瓣跳帧或者init的时候花瓣突然出现在屏幕上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Petal &#123;</span><br><span class="line">  constructor(w, h) &#123;</span><br><span class="line">    this.canvasW = w;  //canvas宽</span><br><span class="line">    this.canvasH = h;  //canvas高</span><br><span class="line">    this.w = 0;        //花瓣宽</span><br><span class="line">    this.h = 0;        //花瓣高</span><br><span class="line">    this.x = 0;        //初始x坐标</span><br><span class="line">    this.y = 0;        //初始y坐标</span><br><span class="line">    this.r = 0;        //初始旋转角度</span><br><span class="line">    this.scale = 1;    //初始缩放</span><br><span class="line">    this.toLarge = false;   //默认放大为false</span><br><span class="line">    this.speedX = 1;   //x方向速度</span><br><span class="line">    this.speedY = 1;   //y方向速度</span><br><span class="line">    this.speedScale= 0.01  //缩放速度</span><br><span class="line">    this.speedR = 0.05    //旋转速度</span><br><span class="line">  &#125;</span><br><span class="line">  //数据初始化，用于当花瓣超出浏览器可视区时重置位置</span><br><span class="line">  async init() &#123;</span><br><span class="line">    this.x = 0;</span><br><span class="line">    this.y = 0;</span><br><span class="line">    this.r = 0;</span><br><span class="line">    this.scale = 1;</span><br><span class="line">    this.speedX = 1;</span><br><span class="line">    this.speedY = 1;</span><br><span class="line">    this.speedScale = 0.01;</span><br><span class="line">    this.speedR = 0.05;</span><br><span class="line">  &#125;</span><br><span class="line">  //画布位移、画图、画布复位</span><br><span class="line">  draw(ctx, img) &#123;</span><br><span class="line">    this.w = img.width;</span><br><span class="line">    this.h = img.height;</span><br><span class="line">    ctx.save();     //保存当前画布状态</span><br><span class="line">    ctx.translate(this.x + this.w / 2,  this.y + this.h / 2);  //画布位移</span><br><span class="line">    ctx.rotate(this.r);   //画布旋转</span><br><span class="line">    ctx.scale(1, this.scale);  //画布缩放</span><br><span class="line">    ctx.drawImage(img, -this.w / 2, -this.h / 2);   //画图</span><br><span class="line">    ctx.restore();    //画布复位</span><br><span class="line">  &#125;</span><br><span class="line">  //计算坐标</span><br><span class="line">  async move() &#123;</span><br><span class="line">    this.x += this.speedX;</span><br><span class="line">    this.y += this.speedY;</span><br><span class="line">    this.r += this.speedR;</span><br><span class="line">    if (this.scale &gt;= 1) &#123;</span><br><span class="line">      this.toLarge = false;</span><br><span class="line">    &#125; else if (this.scale &lt;= 0) &#123;</span><br><span class="line">      this.toLarge = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.toLarge) &#123;</span><br><span class="line">      this.scale += this.speedScale;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.scale -= this.speedScale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.x &gt;= this.canvasW || this.y &gt;= this.canvasH) &#123;</span><br><span class="line">      await this.init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import Petal from &apos;./petal&apos;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0,</span><br><span class="line">      n: 60,</span><br><span class="line">      imgnames: [</span><br><span class="line">        &quot;petal1&quot;,</span><br><span class="line">        &quot;petal2&quot;,</span><br><span class="line">        &quot;petal3&quot;,</span><br><span class="line">        &quot;petal4&quot;,</span><br><span class="line">        &quot;petal5&quot;,</span><br><span class="line">        &quot;petal6&quot;,</span><br><span class="line">        &quot;petal7&quot;,</span><br><span class="line">        &quot;petal8&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.setCanvas = this.setCanvas.bind(this);</span><br><span class="line">    this.componentDidMount = this.componentDidMount.bind(this);</span><br><span class="line">    this.createPetal = this.createPetal.bind(this);</span><br><span class="line">    this.go = this.go.bind(this);</span><br><span class="line">    this.imgLoad = this.imgLoad.bind(this);</span><br><span class="line">    this.allImgLoad = this.allImgLoad.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setCanvas() &#123;</span><br><span class="line">    let W = document.documentElement.clientWidth;</span><br><span class="line">    let H = document.documentElement.clientHeight;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      cw: W,</span><br><span class="line">      ch: H</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  imgLoad(imgname) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        let img = new Image();</span><br><span class="line">        img.src = require(`./images/$&#123;imgname&#125;.png`);</span><br><span class="line">        img.onload = () =&gt; &#123;</span><br><span class="line">          resolve(img);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch(e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  allImgLoad(imgnames) &#123;</span><br><span class="line">    let p = [];</span><br><span class="line">    for(let i = 0; i &lt; imgnames.length; i++) &#123;</span><br><span class="line">      p.push(this.imgLoad(imgnames[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.all(p).then(res =&gt; &#123;</span><br><span class="line">      return res;</span><br><span class="line">    &#125;).catch((e) =&gt; &#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    let imgnames = [];</span><br><span class="line">    let totalNum = this.state.imgnames.length; //图片的总数量</span><br><span class="line">    for (let i = 0; i &lt; this.state.n; i++) &#123;</span><br><span class="line">      let imgname = this.state.imgnames[i % totalNum];</span><br><span class="line">      imgnames.push(imgname);</span><br><span class="line">    &#125;</span><br><span class="line">    let imgs = await this.allImgLoad(imgnames);</span><br><span class="line">    if(!imgs) return;</span><br><span class="line">    for(let i = 0; i &lt; imgs.length; i++) &#123;</span><br><span class="line">      let petal = new Petal(canvas.width, canvas.height);</span><br><span class="line">      this.go(ctx, petal, imgs[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async go(ctx, petal, img, index) &#123;</span><br><span class="line">    let W = this.state.cw;</span><br><span class="line">    let H = this.state.ch;</span><br><span class="line">    //浏览器窗口改变大小时同步更新petal的cnavas宽高值，与花瓣坐标对比判断是否在可视区内</span><br><span class="line">    petal.canvasW = W;</span><br><span class="line">    petal.canvasH = H;</span><br><span class="line">    if( index === 0) &#123;</span><br><span class="line">      ctx.clearRect(0, 0, W, H);//清空画布</span><br><span class="line">    &#125;</span><br><span class="line">    await petal.move();</span><br><span class="line">    petal.draw(ctx, img);</span><br><span class="line"></span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, petal, img, index);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.setCanvas();</span><br><span class="line">    window.onresize = this.setCanvas;</span><br><span class="line">    this.createPetal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;canvas id=&quot;canvas&quot; ref=&quot;canvas&quot; width=&#123;this.state.cw&#125; height=&#123;this.state.ch&#125;&gt;&lt;/canvas&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p>这个时候60个花瓣叠在一起，看一下效果<br><img src="12.gif" alt="Feb-03-2019 14-34-22.gif"></p>
<h5 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h5><p>首先要确定一下花瓣初始化的随机区域，有以下几点要求。<br>1、除了打开页面或者刷新页面，可以出现在浏览器可视区，其他情况下要出现在可视区外，从可视区边缘飘进可视区。<br>2、花瓣移动的路径要经过可视区，并且不会出现在左下角或者右上角只有半个花瓣划过的情况，没有意义。<br>3、分布均匀</p>
<p>接下来就是具体实施，先画个图，便于理解。<br><img src="13.png" alt="image.png"></p>
<p>把浏览器45度向左上方平移，我们需要花瓣出现在两条红线之间的区域，并且当花瓣移出浏览器可视区之后，只能出现在蓝色斜线区域。<br>这里花瓣首先随机出现在整个大矩形里，如果出现在想要的区域外，我们做如下处理：<br><img src="14.png" alt="image.png"><br>这样可以保证所有花瓣都会经过浏览器可视区，左下角和右上角不会出现半个花瓣的情况，并且均匀分布整个浏览器可视区。<br>移动端同理这里就不画图了下面上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const randNum = (min, max) =&gt; &#123;</span><br><span class="line">  return Math.random() * (max - min) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const calculateXY = (w, h) =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let x = randNum(-h + 100, w - 100);</span><br><span class="line">    let y = randNum(-h + 100, h - 100);</span><br><span class="line">    let b = 60;   //这里是加一个偏移量，防止移出可视区后初始化位置时突然在可视区上边缘和做边缘出现。</span><br><span class="line">    if (w &gt;= h) &#123;</span><br><span class="line">      let a = w - h;</span><br><span class="line">      //坐标在canvas区域，移到左上方同canvas大小区域</span><br><span class="line">      if (x &gt; -b &amp;&amp; y &gt; -b) &#123;</span><br><span class="line">        x = randNum(-h + b, a - b);</span><br><span class="line">        y = randNum(-h + b, -b);</span><br><span class="line">      &#125; else if (x &gt; a - b &amp;&amp; y &lt; -(h - (x - a) + b)) &#123;</span><br><span class="line">        //坐标在canvas右上方三角形区域，飘落不经过canvas，移到正上方三角形区域</span><br><span class="line">        y = randNum(-(h - (x - a) + b), -b);</span><br><span class="line">      &#125; else if (x &lt; -b &amp;&amp; y &gt; h + x - b) &#123;</span><br><span class="line">        //坐标在canvas左下方三角形区域，飘落不经过canvas，移到正左方三角形区域</span><br><span class="line">        y = randNum(0, h + x - b);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      let a = h - w;</span><br><span class="line">      if (x &gt; -b &amp;&amp; y &gt; -b) &#123;</span><br><span class="line">        x = randNum(-w + b, -b);</span><br><span class="line">        y = randNum(-w + b, a - b);</span><br><span class="line">      &#125; else if (x &gt; -b &amp;&amp; y &lt; -(w - x) + b) &#123;</span><br><span class="line">        y = randNum(-(w - x) + b, -b);</span><br><span class="line">      &#125; else if (x &lt; -b &amp;&amp; y &gt; h - x - b) &#123;</span><br><span class="line">        y = randNum(a, h - x - b);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(&#123;x, y&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class Petal &#123;</span><br><span class="line">  constructor(w, h) &#123;</span><br><span class="line">    this.canvasW = w;</span><br><span class="line">    this.canvasH = h;</span><br><span class="line">    this.w = 0;</span><br><span class="line">    this.h = 0;</span><br><span class="line">    this.y = randNum(-h + 100, h - 100); //这里两个100是防止直接出现在可视区边缘半个直接飘出去了</span><br><span class="line">    this.x = randNum(-h + 100, w - 100);</span><br><span class="line">    this.r = Math.random();</span><br><span class="line">    this.scale = -Math.random();</span><br><span class="line">    this.toLarge = false;</span><br><span class="line">    this.speedX = Math.random() * 0.5 + 0.5;</span><br><span class="line">    this.speedY = this.speedX;</span><br><span class="line">    this.speedScale = Math.random() * 0.007;</span><br><span class="line">    this.speedR = Math.random() * 0.03;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw(ctx, img) &#123;</span><br><span class="line">    this.w = img.width;</span><br><span class="line">    this.h = img.height;</span><br><span class="line">    ctx.save();</span><br><span class="line">    ctx.translate(this.x + this.w / 2, this.y + this.h / 2);</span><br><span class="line">    ctx.rotate(this.r);</span><br><span class="line">    ctx.scale(1, this.scale);</span><br><span class="line">    ctx.drawImage(img, -this.w / 2, -this.h / 2);</span><br><span class="line">    ctx.restore();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async init() &#123;</span><br><span class="line">    let xy = await calculateXY(this.canvasW, this.canvasH);</span><br><span class="line">    this.x = xy.x;</span><br><span class="line">    this.y = xy.y;</span><br><span class="line">    this.r = Math.random();</span><br><span class="line">    this.scale = -Math.random();</span><br><span class="line">    this.speedX = Math.random() * 0.5 + 0.3;</span><br><span class="line">    this.speedY = this.speedX;</span><br><span class="line">    this.speedScale = Math.random() * 0.004;</span><br><span class="line">    this.speedR = Math.random() * 0.03;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async move() &#123;</span><br><span class="line">    this.x += this.speedX;</span><br><span class="line">    this.y += this.speedY;</span><br><span class="line">    this.r += this.speedR;</span><br><span class="line">    if (this.scale &gt;= 1) &#123;</span><br><span class="line">      this.toLarge = false;</span><br><span class="line">    &#125; else if (this.scale &lt;= 0) &#123;</span><br><span class="line">      this.toLarge = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.toLarge) &#123;</span><br><span class="line">      this.scale += this.speedScale;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.scale -= this.speedScale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.x &gt;= this.canvasW || this.y &gt;= this.canvasH) &#123;</span><br><span class="line">      await this.init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就完成了，看一下帧数。<br>打开chrome开发者模式<br><img src="15.png" alt="image.png"><br>选<code>rendering</code>，勾选<code>FPS meter</code><br><img src="16.png" alt="image.png"><br>可以看到在60左右，是比较理想的<br><img src="17.png" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title>mac mysql8 密码</title>
    <url>/post/macMysql8Password/</url>
    <content><![CDATA[<p>新电脑安装mysql之后第一次是无法登陆的因为没有初始密码，网上都是老版本的处理方法，mysql8已经失效。</p>
<a id="more"></a>
<h3 id="1、停止mysql服务"><a href="#1、停止mysql服务" class="headerlink" title="1、停止mysql服务"></a>1、停止mysql服务</h3><p>系统设置偏好 &gt; mysql &gt; Stop Mysql Server<br><img src="1.png" alt="image.png"></p>
<h3 id="2、跳过登陆"><a href="#2、跳过登陆" class="headerlink" title="2、跳过登陆"></a>2、跳过登陆</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -i      //root权限</span><br><span class="line">sudo mysqld_safe --user=mysql --skip-grant-tables --skip-networking</span><br></pre></td></tr></table></figure>

<p><img src="2.png" alt="image.png"><br><code>这里不要动！！！</code><br>打开另一个终端窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root</span><br></pre></td></tr></table></figure>

<p>直接回车就可以登陆mysql</p>
<h3 id="3、修改密码"><a href="#3、修改密码" class="headerlink" title="3、修改密码"></a>3、修改密码</h3><p>在这里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>

<p>可以看见有个mysql数据库<br><img src="3.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">show tables;</span><br></pre></td></tr></table></figure>

<p>可以看见有个user的表，感兴趣可以看一下。<br>接下来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p><img src="4.png" alt="image.png"><br>重置密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;new password&apos;;</span><br></pre></td></tr></table></figure>

<p>关闭终端，重新打开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p[password]</span><br></pre></td></tr></table></figure>

<p>即可登陆mysql</p>
<h3 id="4、开机启动"><a href="#4、开机启动" class="headerlink" title="4、开机启动"></a>4、开机启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents/</span><br><span class="line">launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>centos 安装mysql8 以及常用sql语句</title>
    <url>/post/centOsInstallMysql/</url>
    <content><![CDATA[<p>安装环境：centos7<br>刚租了台服务器安装mysql的时候发现之前的笔记已经不合适了，更新一下。</p>
<a id="more"></a>
<h4 id="mysql安装配置"><a href="#mysql安装配置" class="headerlink" title="mysql安装配置"></a>mysql安装配置</h4><p>1、检测是否安装过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure>

<p>2、删除当前已安装版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -e --nodeps `rpm -qa | grep mysql`</span><br></pre></td></tr></table></figure>

<p>3、在线安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install mysql-server</span><br></pre></td></tr></table></figure>

<p><code>这里可能会找不到包，如果没有可用的包，按照如下操作</code><br>去这里<a href="http://repo.mysql.com/" target="_blank" rel="noopener">http://repo.mysql.com/</a><br>选择最新版本的<code>mysql-community</code>的<code>rpm包</code>复制链接地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://repo.mysql.com/mysql80-community-release-el7-1.noarch.rpm</span><br><span class="line">rpm -ivh mysql80-community-release-el7-1.noarch.rpm</span><br><span class="line">yum -y install mysql-server</span><br></pre></td></tr></table></figure>

<p>4、开启mysql服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>

<p>5、mysql添加开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig mysqld on</span><br></pre></td></tr></table></figure>

<p>6、初始化配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log    //查看初始密码</span><br><span class="line">2018-12-04T14:08:38.524688Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: #Fwd;l5cl*r*   //初始密码  这很反人类</span><br><span class="line">//下面初始化</span><br><span class="line">whereis mysql_secure_installation    //找到mysql_secure_installation</span><br><span class="line">mysql_secure_installation: /usr/bin/mysql_secure_installation /usr/share/man/man1/mysql_secure_installation.1.gz</span><br><span class="line">/usr/bin/mysql_secure_installation    //直接运行mysql_secure_installation</span><br><span class="line">Securing the MySQL server deployment.</span><br><span class="line"></span><br><span class="line">Enter password for user root:            //输入刚才查看的密码</span><br><span class="line"></span><br><span class="line">The existing password for the user account root has expired. Please set a new password.</span><br><span class="line"></span><br><span class="line">New password:                              //新密码大小写数字加特殊符号</span><br><span class="line"></span><br><span class="line">Re-enter new password:              //重复新密码</span><br><span class="line">The &apos;validate_password&apos; component is installed on the server.</span><br><span class="line">The subsequent steps will run with the existing configuration</span><br><span class="line">of the component.</span><br><span class="line">Using existing password for root.</span><br><span class="line"></span><br><span class="line">Estimated strength of the password: 100</span><br><span class="line">Change the password for root ? ((Press y|Y for Yes, any other key for No) :        //直接跳过  选Y的话是重新设置密码</span><br><span class="line"> ... skipping.</span><br><span class="line">By default, a MySQL installation has an anonymous user,</span><br><span class="line">allowing anyone to log into MySQL without having to have</span><br><span class="line">a user account created for them. This is intended only for</span><br><span class="line">testing, and to make the installation go a bit smoother.</span><br><span class="line">You should remove them before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line">Remove anonymous users? (Press y|Y for Yes, any other key for No) : y  //禁止匿名访问</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from</span><br><span class="line">&apos;localhost&apos;. This ensures that someone cannot guess at</span><br><span class="line">the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : y  //不允许root远程访问</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">By default, MySQL comes with a database named &apos;test&apos; that</span><br><span class="line">anyone can access. This is also intended only for testing,</span><br><span class="line">and should be removed before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y  //删除测试数据库test</span><br><span class="line"> - Dropping test database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"> - Removing privileges on test database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">Reloading the privilege tables will ensure that all changes</span><br><span class="line">made so far will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y  重新加载授权信息</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">All done!</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">#### 常用命令</span><br><span class="line">1、开启/关闭mysql服务</span><br></pre></td></tr></table></figure>

<p>service mysqld stop/restart</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2、访问mysql数据库</span><br></pre></td></tr></table></figure>

<p>mysql -uroot -p[password]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3、显示数据库列表</span><br></pre></td></tr></table></figure>

<p>show databases;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4、选择数据库</span><br></pre></td></tr></table></figure>

<p>use databases;    #数据库名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5、显示表</span><br></pre></td></tr></table></figure>

<p>show tables;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6、显示表结构</span><br></pre></td></tr></table></figure>

<p>describe table;     #表名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7、新建/删除数据库</span><br></pre></td></tr></table></figure>

<p>create database 库名;<br>drop database 库名;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8、建表</span><br></pre></td></tr></table></figure>

<p>##demo##<br>CREATE TABLE user_info(<br>    -&gt; id varchar(30) NOT NULL,<br>    -&gt; user_name varchar(10),<br>    -&gt; password varchar(10),<br>    -&gt; PRIMARY KEY ( <code>id</code> )<br>    -&gt; );</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9、删除表</span><br></pre></td></tr></table></figure>

<p>drop table 表名;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10、清空表中数据</span><br></pre></td></tr></table></figure>

<p>delete from 表名;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11、显示表中所有数据</span><br></pre></td></tr></table></figure>

<p>select * from 表名;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12、表中添加一列  </span><br><span class="line">如果想在一个已经建好的表中添加一列：</span><br></pre></td></tr></table></figure>

<p>alter table TABLE_NAME add column NEW_COLUMN_NAME varchar(20) not null;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这条语句会向已有的表中加入新的一列，这一列在表的最后一列位置。如果我们希望添加在指定的一列：</span><br></pre></td></tr></table></figure>

<p>alter table TABLE_NAME add column NEW_COLUMN_NAME varchar(20) not null after COLUMN_NAME;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意，上面这个命令的意思是说添加新列到某一列后面。如果想添加到第一列的话：</span><br></pre></td></tr></table></figure>

<p>alter table TABLE_NAME add column NEW_COLUMN_NAME varchar(20) not null first;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13、修改一列数据长度/类型</span><br></pre></td></tr></table></figure>

<p>alter table user modify column id varchar(20);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14、删除列</span><br></pre></td></tr></table></figure>

<p>alter table user drop column id;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15、中文显示？？？</span><br></pre></td></tr></table></figure>

<p>service mysqld stop      #关闭mysql<br>whereis my.cnf          #确定配置文件位置<br>vim /etc/my.cnf          #具体情况看自己的路径</p>
<p>#[mysqld]下加以下两行<br>character_set_server=utf8<br>init_connect=’SET NAMES utf8’</p>
<p>#保存退出<br>service mysqld start</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`需要注意的是，之前在默认情况下创建的表的编码格式并不会改变！所以，如果想让在修改编码格式之前就创建好的表也修改，使用如下指令`</span><br><span class="line">`1.修改数据库的编码格式`</span><br></pre></td></tr></table></figure>

<p>alter database &lt;数据库名&gt; character set utf8;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`2.修改数据表格编码格式`</span><br></pre></td></tr></table></figure>

<p>alter table &lt;表名&gt; character set utf8;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`3.修改字段编码格式`</span><br></pre></td></tr></table></figure>

<p>alter table &lt;表名&gt; change &lt;字段名&gt; &lt;字段名&gt; &lt;类型&gt; character set utf8;<br>//demo<br>alter table user change username username varchar(20) character set utf8 not null;</p>
<pre><code>`**修改完的数据库和库里的表 并不会使原来的数据生效，而是新加入的数据才会生效。`</code></pre>]]></content>
  </entry>
  <entry>
    <title>一个移动端翻页的封装</title>
    <url>/post/likeSwiper/</url>
    <content><![CDATA[<p>想写一个移动端的h5页面<br>还不想用swiper那些工具，主要是太大，我需要的仅仅只是一个翻页功能<br>所以自己写了一个  </p>
<a id="more"></a>
<p>地址：<a href="https://github.com/MonkeyInWind/switching" target="_blank" rel="noopener">https://github.com/MonkeyInWind/switching</a><br>效果预览：<a href="https://monkeyinwind.github.io/switching/" target="_blank" rel="noopener">https://monkeyinwind.github.io/switching/</a></p>
<p>下面说一下用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/MonkeyInWind/switching.git</span><br><span class="line">cd switching</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>安装好之后</p>
<p>开发模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>打包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>先说一下功能：<br>可以根据手滑动的八个方向切换界面<br>左上、上、右上 、右  这四个方向是下一页<br>左下、下、右下、左   这四个方向是上一页<br>手滑向哪个方向  被滑走的界面就飞向哪个方向<br>做了手指滑出屏幕判断<br>切换界面会触发slide事件  可以做动画<br>配置了babel和postcss  </p>
<p>用法：<br>html结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;main_container&quot;&gt;</span><br><span class="line">    &lt;section style=&quot;background-color: red&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;div2&quot;&gt;</span><br><span class="line">            &lt;img src=&quot;./src/img/aa.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;section style=&quot;background-color: blue&quot;&gt;&lt;/section&gt;</span><br><span class="line">    &lt;section style=&quot;background-color: yellow&quot;&gt;&lt;/section&gt;</span><br><span class="line">    &lt;section style=&quot;background-color: green&quot;&gt;&lt;/section&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Switch = new Switching(&#123;</span><br><span class="line">    target: &apos;.main_container&apos;</span><br><span class="line">&#125;);</span><br><span class="line">Switch.on(&apos;slide&apos;, function (e) &#123;</span><br><span class="line">    console.log(e);  //返回一个对象 属性包括当前界面的index   当前界面DOM节点  所有界面的DOM   滑动方向</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Linux下安装Nginx</title>
    <url>/post/installNginxInLinux/</url>
    <content><![CDATA[<h3 id="1、安装依赖"><a href="#1、安装依赖" class="headerlink" title="1、安装依赖"></a>1、安装依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="2、下载安装包"><a href="#2、下载安装包" class="headerlink" title="2、下载安装包"></a>2、下载安装包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local</span><br></pre></td></tr></table></figure>

<p><a href="http://nginx.org/download/" target="_blank" rel="noopener">http://nginx.org/download/</a><br>去上边地址找到自己想要安装的版本复制连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.9.9.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h3><p>解压到当前文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf nginx-1.9.9.tar.gz</span><br><span class="line">cd nginx-1.9.9</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>安装完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<p>会发现多了一个nginx的文件夹，nginx就被安装在这个目录下（nginx-1.9.9的文件夹和压缩包可以删了），测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd nginx/sbin</span><br><span class="line">./nginx -t</span><br></pre></td></tr></table></figure>

<p>打印如下信息， 安装完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>

<h3 id="4、常用命令"><a href="#4、常用命令" class="headerlink" title="4、常用命令"></a>4、常用命令</h3><p>安装路径 <code>/usr/local/nginx</code> 下</p>
<p>开启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./sbin/nginx</span><br></pre></td></tr></table></figure>

<p>关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./sbin/nginx -s stop (或者：nginx -s quit)</span><br></pre></td></tr></table></figure>

<p>重启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./sbin/nginx -s reload</span><br></pre></td></tr></table></figure>

<p>查看进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>视频切片转m3u8</title>
    <url>/post/videoToM3U8/</url>
    <content><![CDATA[<h3 id="1、安装ffmpeg"><a href="#1、安装ffmpeg" class="headerlink" title="1、安装ffmpeg"></a>1、安装ffmpeg</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="2-安装ffmpeg依赖"><a href="#2-安装ffmpeg依赖" class="headerlink" title="2. 安装ffmpeg依赖"></a>2. 安装ffmpeg依赖</h3><p>查看安装信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew info ffmpeg</span><br></pre></td></tr></table></figure>

<p>会显示依赖安装情况❌ 表示未安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install 需要安装的依赖</span><br></pre></td></tr></table></figure>

<h3 id="3-视频转换"><a href="#3-视频转换" class="headerlink" title="3. 视频转换"></a>3. 视频转换</h3><p>查看视频信息，只有视频编码h.264，音频编码aac的mp4视频可以转m3u8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffprobe trailer.mp4(视频文件+后缀 我的源文件就是mp4)</span><br></pre></td></tr></table></figure>

<p> 显示如下信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ffprobe version 3.4 Copyright (c) 2007-2017 the FFmpeg developers</span><br><span class="line"> built with Apple LLVM version 9.0.0 (clang-900.0.37)</span><br><span class="line">configuration: --prefix=/usr/local/Cellar/ffmpeg/3.4 --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --enable-avresample --cc=clang --    host-cflags= --host-ldflags= --enable-gpl --enable-libmp3lame --enable-libx264 --enable-libxvid --enable-opencl --enable-videotoolbox --disable-lzma</span><br><span class="line">libavutil      55. 78.100 / 55. 78.100</span><br><span class="line">libavcodec     57.107.100 / 57.107.100</span><br><span class="line"> libavformat    57. 83.100 / 57. 83.100</span><br><span class="line"> libavdevice    57. 10.100 / 57. 10.100</span><br><span class="line"> libavfilter     6.107.100 /  6.107.100</span><br><span class="line"> libavresample   3.  7.  0 /  3.  7.  0</span><br><span class="line"> libswscale      4.  8.100 /  4.  8.100</span><br><span class="line"> libswresample   2.  9.100 /  2.  9.100</span><br><span class="line"> libpostproc    54.  7.100 / 54.  7.100</span><br><span class="line"> Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &apos;trailer.mp4&apos;:</span><br><span class="line"> Metadata:</span><br><span class="line">   major_brand     : mp42</span><br><span class="line">   minor_version   : 0</span><br><span class="line">   compatible_brands: mp42mp41</span><br><span class="line">   creation_time   : 2017-11-27T13:16:02.000000Z</span><br><span class="line">   Duration: 00:04:02.47, start: 0.000000, bitrate: 10342 kb/s</span><br><span class="line">   Stream #0:0(eng): Video: h264 (Main) (avc1 / 0x31637661), yuv420p(tv, bt709), 1920x1080, 10018 kb/s, 25 fps, 25 tbr, 25k tbn, 50 tbc (default)</span><br><span class="line">    Metadata:</span><br><span class="line">     creation_time   : 2017-11-27T13:16:02.000000Z</span><br><span class="line">      handler_name    : Alias Data Handler</span><br><span class="line">    encoder         : AVC Coding</span><br><span class="line">   Stream #0:1(eng): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 317 kb/s (default)</span><br><span class="line">   Metadata:</span><br><span class="line">    creation_time   : 2017-11-27T13:16:02.000000Z</span><br><span class="line">     handler_name    : Alias Data Handler</span><br></pre></td></tr></table></figure>

<p> 视频转mp4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 视频源文件.后缀 -acodec copy -vcodec copy out.mp4</span><br></pre></td></tr></table></figure>

<p>视频如果太大可以压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input_file -s 320x240 output_file</span><br></pre></td></tr></table></figure>

<p>分辨率自己看着改</p>
<p>mp4转ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -c copy -bsf:v h264_mp4toannexb output.ts</span><br></pre></td></tr></table></figure>

<p>视频切片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i output.ts -c copy -map 0 -f segment -segment_list playlist.m3u8 -segment_time 5 output%03d.ts</span><br></pre></td></tr></table></figure>

<p>命令里边的5为每段视频5秒，可自行调整，完成之后会生成一个playlist.m3u8和一堆.ts,切片到这里就完成了。</p>
<h3 id="4-页面插入视频"><a href="#4-页面插入视频" class="headerlink" title="4. 页面插入视频"></a>4. 页面插入视频</h3><p>试了两种方式<br>一种是video.js + videojs-contrib-hls.js<br>这种方式不兼容IE10-<br><a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">video.js</a><br><a href="https://github.com/videojs/videojs-contrib-hls" target="_blank" rel="noopener">videojs-contrib-hls</a></p>
<pre><code>&lt;video id=example-video width=960 height=540 class=&quot;video-js vjs-default-skin&quot; controls&gt;
    &lt;source src=&quot;./video/playlist.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt;
&lt;/video&gt;
&lt;script src=&quot;video.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;videojs.hls.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var player = videojs(&apos;example-video&apos;);
    player.play();
&lt;/script&gt;</code></pre><p>另一种方式用ckplayer<br>官网：<a href="http://www.ckplayer.com/" target="_blank" rel="noopener">http://www.ckplayer.com/</a><br>下载之后解压找到<code>crossdomain.xml</code>和<code>ckplayer</code>文件夹放到根目录下  </p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;ckplayer/ckplayer.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;video&quot; style=&quot;width:600px;height:400px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var videoObject = {
        container:&apos;#video&apos;,
        variable:&apos;player&apos;,
        autoplay:true, //强制使用ckplay做播放器
        video:&apos;./video/playlist.m3u8&apos;
    };
    var player=new ckplayer(videoObject);
&lt;script&gt;</code></pre><p>视频会带ckplay的水印，但是不影响。</p>
]]></content>
  </entry>
  <entry>
    <title>用了react-router刷新404 nginx配置</title>
    <url>/post/reactRouterNginx/</url>
    <content><![CDATA[<p>react项目用了react-router<br>发现只有首页可以访问，在子页面刷新时not found  </p>
<a id="more"></a>
<p>nginx配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">  server_name xxx.xxxxxxx.com;  </span><br><span class="line">  location / &#123;  </span><br><span class="line">    proxy_pass http://11.11.11.11:1111/; (node服务端口)  </span><br><span class="line">    root html;  </span><br><span class="line">    index index.html index.htm;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为他会根据url去找相应路径下的html<br>但是react只有一个index.html入口<br>需要改成静态路径并且加一行 <code>try_files $uri /index.html;</code><br>无论uri是否变化<br>都返回index.html  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">  server_name xxx.xxxxxx.com;  </span><br><span class="line">  location / &#123;  </span><br><span class="line">    root /xxx/xxx/xxx/www/build;  </span><br><span class="line">    try_files $uri /index.html;  </span><br><span class="line">  &#125;  </span><br><span class="line">  location ^~ /api/ &#123;  </span><br><span class="line">    proxy_pass http://11.11.11.11:1111/;(服务端接口做代理)  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>flutter for web</title>
    <url>/post/flutterForWeb/</url>
    <content><![CDATA[<p>谷歌开发者大会上宣布flutter1.9正式发布，并且flutter_web已经合到dev合master。<br>我们来体验一下。  </p>
<a id="more"></a>
<p>首先切换到master并升级flutter到最新版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter channel master</span><br><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure>

<p>安装<code>webdev</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter pub global activate webdev</span><br></pre></td></tr></table></figure>

<p>这里需要注意一下，安装之后看提示还要添加环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Installed executable webdev.</span><br><span class="line">Warning: Pub installs executables into $HOME/.pub-cache/bin, which is not on your path.</span><br><span class="line">You can fix that by adding this to your shell&apos;s config file (.bashrc, .bash_profile, etc.):</span><br><span class="line"></span><br><span class="line">  export PATH=&quot;$PATH&quot;:&quot;$HOME/.pub-cache/bin&quot;</span><br><span class="line"></span><br><span class="line">Activated webdev 2.5.1.</span><br></pre></td></tr></table></figure>

<p>打开<code>~ &gt; .bash_profile</code>把<code>export PATH=&quot;$PATH&quot;:&quot;$HOME/.pub-cache/bin&quot;</code>添加进去，然后更新环境变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>到这<code>webdev</code>就完事了，命令行敲<code>webdev</code>测试一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webdev</span><br><span class="line">/Users/xxx/.pub-cache/bin/webdev: line 7: dart: command not found</span><br></pre></td></tr></table></figure>

<p>惊不惊喜，意不意外，这是因为<code>dart</code>没有添加环境变量。<br>在<code>.bash_profile</code>中添加dart环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export DART_HOME=/Users/xxx/sdk/flutter/bin/cache/dart-sdk/bin</span><br><span class="line">export PATH=$&#123;DART_HOME&#125;:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure>

<p>刷新环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>重新试一下<code>webdev</code>如果显示如下，说明没有问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A tool to develop Dart web projects.</span><br><span class="line"></span><br><span class="line">Usage: webdev &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">Global options:</span><br><span class="line">-h, --help       Print this usage information.</span><br><span class="line">    --version    Prints the version of webdev.</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line">  build   Run builders to build a package.</span><br><span class="line">  help    Display help information for webdev.</span><br><span class="line">  serve   Run a local web development server and a file system watcher that rebuilds on changes.</span><br><span class="line"></span><br><span class="line">Run &quot;webdev help &lt;command&gt;&quot; for more information about a command.</span><br></pre></td></tr></table></figure>

<p>这里需要注意一下，如果没有用<code>flutter</code>自带的<code>dart-sdk</code>而是单独安装，这里可能会因为dart版本与flutter版本不匹配而出现如下提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Can&apos;t load Kernel binary: Invalid kernel binary format version.</span><br><span class="line">No active package webdev.</span><br></pre></td></tr></table></figure>

<p>出现这种情况把dart卸载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew uninstall dart</span><br></pre></td></tr></table></figure>

<p>然后如前边所述将flutter内置的dart-sdk添加到环境变量就可以了。<br>启用<code>flutter_web</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter config --enable-web</span><br></pre></td></tr></table></figure>

<p>出现如下提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting &quot;enable-web&quot; value to &quot;true&quot;.</span><br></pre></td></tr></table></figure>

<p>接下来创建一个flutter项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter create myapp</span><br><span class="line">cd myapp</span><br></pre></td></tr></table></figure>

<p>可以看见目录下多了一个<code>web</code>文件夹里边是一个<code>index.html</code>，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;myapp&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script src=&quot;main.dart.js&quot; type=&quot;application/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>从这里可以看见，最终也是编译成js文件。<br>先看一下已连接的设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  myapp flutter devices</span><br><span class="line">3 connected devices:</span><br><span class="line"></span><br><span class="line">macOS  • macOS  • darwin-x64     • Mac OS X 10.14.5 18F132</span><br><span class="line">Chrome • chrome • web-javascript • Google Chrome 76.0.3809.132</span><br><span class="line">Server • web    • web-javascript • Flutter Tools</span><br></pre></td></tr></table></figure>

<p>这里合之前相比多了<code>Chrome</code>和<code>Server</code></p>
<p>在chrome里跑一下项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter run -d chrome</span><br></pre></td></tr></table></figure>

<p>效果如下，一个熟悉的页面。<br><img src="1.png" alt="image.png"><br>可以看见大多数都是自定义标签，当然也不全是自定义，比如中间那一行文本和数字就是<code>p</code>标签，关于渲染<code>flutter</code>用了<a href="https://developers.google.com/web/updates/2018/01/paintapi" target="_blank" rel="noopener">CSS Paint</a>（能不能打开看缘分），就是用css画图，挺有意思的api。<br>点<code>sources</code>，然后<code>command+o</code><br><img src="2.png" alt="image.png"><br>可以看见这里并不是js文件，而是dart文件。<br>选择<code>main.dart</code>，看到的就是<code>main.dart</code>的源码。<br>接下来说一下调试，直接用chrome的开发者工具查找DOM是比较困难的，这个时候需要<code>android Studio</code>，在<code>android Studio</code>中打开<code>myapp</code>，设备选择<code>chrome(web)</code>，点绿色的三角跑起来<br><img src="3.png" alt="image.png"><br>在<code>View &gt; Tool Windows</code>下选择<code>Flutter Inspector</code><br><img src="4.png" alt="image.png"><br>打开之后是这个样子<br><img src="5.png" alt="image.png"><br>可以看到不知道多少个层级<br><img src="6.png" alt="image.png"><br>这个按钮可以在页面上显示<code>widget</code>的边界<br><img src="7.png" alt="image.png"><br>这个准星一样的按钮相当于浏览器的审查元素，点击之后页面左下角会出现一个放大镜，想要重新在页面上选择元素需要点击放大镜，也可以在<code>Inspector</code>之中直接选择，页面上对应的元素会高亮。<br>这里再说一下另一种方式，chrome内置了<code>Dart DevTools</code><br>项目跑起来之后点下边这个按钮<br><img src="8.png" alt="image.png"><br>chrome会弹出个新窗口<br><img src="9.png" alt="image.png"><br>和<code>Flutter Insector</code>类似，但是更好用一点。</p>
<p>关于<code>dart</code>文件的调试，和js一样可以打断点<br><img src="10.png" alt="image.png"></p>
<p>接下来是打包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  myapp flutter build web</span><br><span class="line">Compiling lib/main.dart for the Web...                             26.4s</span><br></pre></td></tr></table></figure>

<p>build结束后看一下<code>build &gt; web</code>目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  web ls</span><br><span class="line">assets           index.html       main.dart.js     main.dart.js.map</span><br></pre></td></tr></table></figure>

<p><code>dart</code>被编译成了js</p>
]]></content>
  </entry>
</search>
