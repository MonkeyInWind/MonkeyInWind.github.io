<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>图片Image</title>
    <url>/post/imageWidget/</url>
    <content><![CDATA[<p>先看一下constructor</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Image(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  @required ImageProvider image,                        //抽象的构造函数，提供图片加载入口</span><br><span class="line">  String semanticLabel,                                  //语义标签</span><br><span class="line">  bool excludeFromSemantics: false,                    //看文档好像是语义化</span><br><span class="line">  double width,                                           //宽</span><br><span class="line">  double height,                                         //高            </span><br><span class="line">  Color color,                                            //混合色值</span><br><span class="line">  BlendMode colorBlendMode,                              //混合模式</span><br><span class="line">  BoxFit fit,                                           //填充模式</span><br><span class="line">  AlignmentGeometry alignment: Alignment.center,          //对齐方式</span><br><span class="line">  ImageRepeat repeat: ImageRepeat.noRepeat,              //重复方式</span><br><span class="line">  Rect centerSlice,                                      //图片拉伸</span><br><span class="line">  bool matchTextDirection: false,                        //是否按书写方向绘制图片</span><br><span class="line">  bool gaplessPlayback: false,                          //图片路径发生改变后，加载新图片过程中是否显示旧图</span><br><span class="line">  FilterQuality filterQuality: FilterQuality.low        //看官网说貌似和图片质量有关系</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="一、加载一张图片"><a href="#一、加载一张图片" class="headerlink" title="一、加载一张图片"></a>一、加载一张图片</h2><p>flutter提供了4中图片的加载方式</p>
<h3 id="1、本地图片"><a href="#1、本地图片" class="headerlink" title="1、本地图片"></a>1、本地图片</h3><p>首先新建一个<code>images</code>的文件夹，随便放一张图片进去，我这里在官网下载了flutter的logo<br><img src="1.png" alt="image.png"></p>
<p>打开<code>pubspec.yaml</code>在<code>flutter</code>下添加<code>assets</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter:</span><br><span class="line">  uses-material-design: true</span><br><span class="line">  assets:</span><br><span class="line">    - images/logo.png</span><br></pre></td></tr></table></figure>

<p>接下来上代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  // This widget is the root of your application.</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;Flutter Demo&apos;,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        body: new Center(</span><br><span class="line">          child: new Image(</span><br><span class="line">            image: AssetImage(&quot;images/logo.png&quot;)</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一张本地图片就加载完成了。如果有2倍图3倍图需要在images文件夹下建<code>2.0x/3.0x</code>文件夹。<br>flutter还提供了简写的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body: new Center(</span><br><span class="line">  child: new Image.asset(&apos;images/logo.png&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>是不是有问题，一张两张图片还可以，静态文件多了都要添加在<code>pubspec.yaml</code>是不是很麻烦，fultter支持只写文件夹路径，注意<code>/</code>不要忘了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter:</span><br><span class="line">  uses-material-design: true</span><br><span class="line">  assets:</span><br><span class="line">    - images/</span><br></pre></td></tr></table></figure>

<h3 id="2、网络图片"><a href="#2、网络图片" class="headerlink" title="2、网络图片"></a>2、网络图片</h3><p>本地图片需要添加到<code>pubspec.yaml</code>网络图片直接按上边的方法写是肯定不行的，需要用<code>NetworkImage</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body: new Center(</span><br><span class="line">  child: new Image(</span><br><span class="line">    image: NetworkImage(&apos;https://cdn.jsdelivr.net/gh/flutterchina/website@1.0/images/flutter-mark-square-100.png&apos;)</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对于网络图片flutter同样提供了简写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body: new Center(</span><br><span class="line">  child: new Image.network(&apos;https://cdn.jsdelivr.net/gh/flutterchina/website@1.0/images/flutter-mark-square-100.png&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="3、FileImage"><a href="#3、FileImage" class="headerlink" title="3、FileImage"></a>3、FileImage</h3><h3 id="4、Image-momery"><a href="#4、Image-momery" class="headerlink" title="4、Image.momery"></a>4、Image.momery</h3><h2 id="二、设置样式-属性"><a href="#二、设置样式-属性" class="headerlink" title="二、设置样式/属性"></a>二、设置样式/属性</h2><h3 id="1、semanticLabel-amp-excludeFromSemantics"><a href="#1、semanticLabel-amp-excludeFromSemantics" class="headerlink" title="1、semanticLabel &amp; excludeFromSemantics"></a>1、semanticLabel &amp; excludeFromSemantics</h3><p><code>semanticLabel</code>看文档应该是和html里img标签的alt属性类似。<br><code>excludeFromSemantics</code>如果为true，则<code>semanticLabel</code>被忽略。</p>
<h3 id="2、width-amp-height"><a href="#2、width-amp-height" class="headerlink" title="2、width &amp; height"></a>2、width &amp; height</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body: new Center(</span><br><span class="line">  child: new Image(</span><br><span class="line">    image: new AssetImage(&apos;images/logo.png&apos;),</span><br><span class="line">    width: 50.0,</span><br><span class="line">    height: 50.0</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，图片的宽高是等比缩放，并且图片显示不会超过原图的尺寸，下面解释一下。<br>比如一张尺寸为<code>200.0*200.0</code>的图片。<br>1、单方向设置尺寸，例：设置<code>width</code>为<code>100.0</code>，则<code>height</code>等比例调整为<code>100.0</code>。<br>2、如果同时设置宽高，设置的尺寸小于等于图片尺寸，但是与原图比例不同：<code>width: 100.0, height: 200.0</code>，则<code>image</code>这个节点为设置的尺寸，但是图片显示为宽<code>100.0</code>高<code>100.0</code>，居中显示。<br>3、如果同时设置尺寸，并且两个尺寸都大于图片的实际尺寸，例：<code>width: 300.0, height: 300.0</code>，则<code>image</code>这个节点为设置的尺寸即<code>300.0*300.0</code>，图片显示为图片本身的尺寸即<code>200.0*200.0</code>居中显示。</p>
<h3 id="3、color"><a href="#3、color" class="headerlink" title="3、color"></a>3、color</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">color: Colors.red</span><br></pre></td></tr></table></figure>

<p>如果和我一样用了flutter官网的logo，会发现图片变成了红色，这个是设置图片的前景色，会覆盖图片，如果不是背景色透明的图片，会把整张图片覆盖。</p>
<h3 id="4、colorBlendMode"><a href="#4、colorBlendMode" class="headerlink" title="4、colorBlendMode"></a>4、colorBlendMode</h3><p>混合模式，这里先不说单开一篇分析一下混合模式。</p>
<h3 id="5、fit"><a href="#5、fit" class="headerlink" title="5、fit"></a>5、fit</h3><p>上边说<code>width&amp;height</code>的时候，如果设置的宽高大于图片本身的尺寸，图片会以本身的尺寸居中显示，如果想让他以设置的尺寸显示，就需要这个fit。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Image(</span><br><span class="line">  image: new AssetImage(&apos;images/logo.png&apos;),</span><br><span class="line">  width: 300.0,</span><br><span class="line">  height: 300.0,</span><br><span class="line">  fit: BoxFit.fill</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>fill</code>：设置多少就是多少，图片会被拉伸。<br><code>contain</code>: 缩放图片以完全装图片，可能有部分空白。<br><code>cover</code>: 缩放图片以完全覆盖图片区域，图片可能有部分看不见。<br><code>fitHeight</code>: 充满高，可能有部分图片无法显示。<br><code>fitWidth</code>：充满宽，可能有部分图片无法显示。<br><code>scaleDown</code>：在不大于原图尺寸的情况下，与<code>contain</code>效果相同，如果超过原图尺寸，则以原图大小居中显示。<br>经过总结发现这个<code>fit</code>有一些属性和css中<code>background-size</code>效果相同，比如<code>cover/contain</code>。</p>
<h3 id="6、alignment"><a href="#6、alignment" class="headerlink" title="6、alignment"></a>6、alignment</h3><p>对齐方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child: new Image(</span><br><span class="line">  image: new AssetImage(&apos;images/logo.png&apos;),</span><br><span class="line">  width: 100.0,</span><br><span class="line">  height: 100.0,</span><br><span class="line">  alignment: Alignment.center,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里不详细说了，和<code>Container</code>的<code>alignment</code>写法效果一样，<code>需要注意的是，image的alignment作用在自己身上，Container的alignment作用在子节点身上</code>。</p>
<h3 id="7、repeat"><a href="#7、repeat" class="headerlink" title="7、repeat"></a>7、repeat</h3><p>图片的重复方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body: new Center(</span><br><span class="line">  child: new Image(</span><br><span class="line">    image: new AssetImage(&apos;images/logo.png&apos;),</span><br><span class="line">    width: 400.0,</span><br><span class="line">    height: 400.0,</span><br><span class="line">    repeat: ImageRepeat.repeat,</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>repeat</code>：重复。<br><code>repeatX</code>：X方向重复。<br><code>repeatY</code>：Y方向重复。<br><code>noRepeat</code>：不重复，默认值。</p>
<h3 id="8、centerSlice"><a href="#8、centerSlice" class="headerlink" title="8、centerSlice"></a>8、centerSlice</h3><p>当图片需要被拉伸时，<code>centerSlice</code>定义了一个矩形区域，这个矩形区域有9个点，拉伸作用在这9个点上。上、下、左、右、左上、右上、左下、右下、正中心。</p>
<h3 id="9、matchTextDirection"><a href="#9、matchTextDirection" class="headerlink" title="9、matchTextDirection"></a>9、matchTextDirection</h3><p>是否按书写方向绘制，据说需要配合<code>Directionality</code>使用，但是<code>Image</code>并没有<code>Directionality</code>，如果说<code>Directionality</code>要加在父节点上，<code>Container</code>也没有，没整明白怎么用。</p>
<h3 id="10、gaplessPlayback"><a href="#10、gaplessPlayback" class="headerlink" title="10、gaplessPlayback"></a>10、gaplessPlayback</h3><p>当图片路径发生改变时，重新加载图片过程中原图是否保留展示。<br><code>true</code>：保留。<br><code>false</code>：不保留，空白等待新图片加载完成。</p>
<h3 id="11、filterQuality"><a href="#11、filterQuality" class="headerlink" title="11、filterQuality"></a>11、filterQuality</h3><p>貌似是图片质量相关，加了之后没看出来有什么效果。</p>
<p><code>Image</code>就到这里了，有一些属性和css里的<code>background</code>效果基本相同，可以对比来看，还有不知道怎么用的，有大佬知道希望告知。</p>
]]></content>
  </entry>
  <entry>
    <title>容器组件Container</title>
    <url>/post/containerWidget/</url>
    <content><![CDATA[<p>上一篇笔记用了个<code>Container</code>组件，这一篇详细介绍一下，整体来说这个组件类似<code>div</code>，但是与<code>div</code>又不同，具体有哪些特性，先了解一下<code>Container</code>有哪些属性再总结，因为不了解有哪些属性直接看的话，会有点懵逼。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Container(&#123;</span><br><span class="line">  Key key,</span><br><span class="line">  AlignmentGeometry alignment,        //子组件的对齐方式</span><br><span class="line">  EdgelnsetsGeometry padding,          //内边距</span><br><span class="line">  Color color,                          //背景色</span><br><span class="line">  Decoration decoration,                //背景装饰  相当于样式  在child之下</span><br><span class="line">  Decoration foregroundDecoration,      //前景装饰  覆盖在child之上  如半透明遮罩效果</span><br><span class="line">  double width,                         //宽</span><br><span class="line">  double height,                         //高</span><br><span class="line">  BoxConstraints constraints,           //容器的大小限制</span><br><span class="line">  EdgelnsetsGeometry margin,            //外边距</span><br><span class="line">  Matrix4 transform,                     //变换</span><br><span class="line">  Widget child                            //子节点</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="1、alignment"><a href="#1、alignment" class="headerlink" title="1、alignment"></a>1、alignment</h2><p>子组件的对齐方式，<code>有子组件并且当前Container尺寸大于子组件尺寸时有效</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Container(</span><br><span class="line">  color: Colors.red,</span><br><span class="line">  width: 400.0,</span><br><span class="line">  height: 400.0,</span><br><span class="line">  alignment: Alignment.center,</span><br><span class="line">  child: new Container(</span><br><span class="line">    color: Colors.blue,</span><br><span class="line">    width: 50.0,</span><br><span class="line">    height: 50.0,</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>center</code>：居中<br><code>centerLeft</code>：靠左垂直居中<br><code>centerRight</code>：靠右垂直居中<br><code>bottomCenter</code>：底部居中<br><code>bottomLeft</code>：左下<br><code>bottomRight</code>：右下<br><code>topCenter</code>：顶部居中<br><code>topLeft</code>：左上<br><code>topRight</code>：右上<br>可以看见除了<code>center</code>，都是两个单词拼在一起很好记，垂直方向在前，水平方向在后。<br>子组件尺寸要小于当前组件尺寸时才会生效。</p>
<h2 id="2、padding-amp-margin"><a href="#2、padding-amp-margin" class="headerlink" title="2、padding &amp; margin"></a>2、padding &amp; margin</h2><p>这两个放一起，设置方式相同，这里以padding为例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Container(</span><br><span class="line">  padding: EdgeInsets.all(10.0)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>EdgeInsets.all</code>：四个内边距值相同<br><code>EdgeInsets.only</code>：四个边距单独设置，不设置则为0，用法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">padding: EdgeInsets.only(</span><br><span class="line">  top: 10.0,</span><br><span class="line">  left: 20.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>可以只写一个，也可以四个全都写。<br><code>EdgeInsets.symmetric</code>：可以设置同方向上的两个内边距</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">padding: EdgeInsets.symmetric(</span><br><span class="line">  horizontal: 10.0,        //水平方向两个边距</span><br><span class="line">  vertical: 20.0          //垂直方向两个边距</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>EdgeInsets.zero</code>：设置内边距为0<br><code>EdgeInsets.fromLTRB</code>：<code>only</code>的简写，顺序为左上右下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">padding: EdgeInsets.fromLTRB(10.0, 20.0, 30.0, 40.0)</span><br></pre></td></tr></table></figure>

<p><code>EdgeInsets.fromWindowPadding</code>：具体用法不知道<br><code>***EdgeInsets这个组件是个公用组件，并不是只有padding可以用，比如margin也可以</code></p>
<h2 id="3、color"><a href="#3、color" class="headerlink" title="3、color"></a>3、color</h2><p>背景色。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Container(</span><br><span class="line">  color: Colors.red</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="4、decoration"><a href="#4、decoration" class="headerlink" title="4、decoration"></a>4、decoration</h2><p><code>***decoration不能和color同时用，会报错。</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const BoxDecoration(&#123;</span><br><span class="line">  Color color,</span><br><span class="line">  DecorationImage image,</span><br><span class="line">  BoxBorder border,</span><br><span class="line">  BorderRadiusGeometry borderRadius,</span><br><span class="line">  List&lt;BoxShadow&gt; boxShadow,</span><br><span class="line">  Gradient gradient,</span><br><span class="line">  BlendMode backgroundBlendMode,</span><br><span class="line">  BoxShape shape: BoxShape.rectangle</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="color"><a href="#color" class="headerlink" title="color"></a>color</h4><p>和color一样，没啥说的。</p>
<h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>背景图，可以和背景色一起使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">decoration: BoxDecoration(</span><br><span class="line">  image: DecorationImage(</span><br><span class="line">  //这里先用网图，怎么加载本地资源以后再细说</span><br><span class="line">    image: new NetworkImage(&apos;https://cdn.jsdelivr.net/gh/flutterchina/website@1.0/images/flutter-mark-square-100.png&apos;)</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="border"><a href="#border" class="headerlink" title="border"></a>border</h4><p>边框，在container内部，和<code>margin/padding</code>类似，可以单独设置也可以设置为统一样式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">decoration: BoxDecoration(</span><br><span class="line">  //border: Border.all(width: 2.0, color: Colors.blue)          设置为相同样式</span><br><span class="line">  top: BorderSide(width: 2.0, color: Colors.blue),</span><br><span class="line">  left: BorderSide(width: 4.0, color: Colors.yellow),</span><br><span class="line">  right: BorderSide(width: 8.0, color: Colors.green),</span><br><span class="line">  bottom: BorderSide(width: 16.0, color: Colors.purple)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="borderRadius"><a href="#borderRadius" class="headerlink" title="borderRadius"></a>borderRadius</h4><p><code>*圆角不能和border同时设置，同时存在时可以运行但是会抛出一个异常</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">decoration: new BoxDecoration(</span><br><span class="line">  borderRadius: BorderRadius.only(                   //only对每个角单独设置</span><br><span class="line">    bottomLeft: Radius.circular(20.0),                  //圆角值为20.0</span><br><span class="line">    topLeft: Radius.zero,                                      //圆角为0</span><br><span class="line">    bottomRight: Radius.elliptical(20.0, 40.0)       //圆角x方向为20.0，y方向为40.0</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>Radius.all</code>：四个角同时设置，参数和但方向的参数相同（<code>borderRadius: new BorderRadius.all(Radius.circular(20.0))</code>）。<br><code>Radius.lerp</code>: 做动画用的多一点暂时先不深入。</p>
<h4 id="boxShadow"><a href="#boxShadow" class="headerlink" title="boxShadow"></a>boxShadow</h4><p>容器阴影</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">decoration: new BoxDecoration(</span><br><span class="line">  boxShadow: [</span><br><span class="line">    new BoxShadow(</span><br><span class="line">      color: Colors.red,                      //阴影颜色</span><br><span class="line">      offset: Offset(10.0, 20.0),          //偏移量x, y</span><br><span class="line">      blurRadius: 10.0,                      //模糊</span><br><span class="line">      spreadRadius: 10.0                  //延伸</span><br><span class="line">    ),</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="gradient"><a href="#gradient" class="headerlink" title="gradient"></a>gradient</h4><p>背景色渐变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> //径向渐变</span><br><span class="line">decoration: BoxDecoration(</span><br><span class="line">  gradient: RadialGradient(                         </span><br><span class="line">    colors: [Colors.red, Colors.blue],            //渐变颜色</span><br><span class="line">    center: Alignment.topLeft,                      //渐变中心点，可以设具体数值（center: const Alignment(0.7, -0.6)）</span><br><span class="line">    radius: 5.0                                              //渐变半径</span><br><span class="line">    stops: [0.4, 1.0],                                    //渐变颜色的比例</span><br><span class="line">  ),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//线性渐变</span><br><span class="line">gradient: LinearGradient(</span><br><span class="line">  begin: Alignment.topLeft,                            //渐变起始点</span><br><span class="line">  end: Alignment(0.1, 0.1),                            //结束点</span><br><span class="line">  colors: [Colors.red, Colors.blue],              </span><br><span class="line">  tileMode: TileMode.mirror                          //模式有三个值（mirror：镜像，clamp: 单纯的单次渐变不做其他处理，repeated: 重复）</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//扇形渐变</span><br><span class="line">gradient: SweepGradient(</span><br><span class="line">  center: FractionalOffset.center,    //渐变的圆心</span><br><span class="line">  startAngle: 0.0,                      //渐变的起始角度</span><br><span class="line">  endAngle: math.pi * 2,          //渐变的角度范围</span><br><span class="line">  colors: const &lt;Color&gt;[</span><br><span class="line">    Colors.blue,</span><br><span class="line">    Colors.green,</span><br><span class="line">    Colors.red,</span><br><span class="line">    Colors.yellow,</span><br><span class="line">    Colors.pink</span><br><span class="line">  ],</span><br><span class="line">  stops: const &lt;double&gt;[0.0, 0.25, 0.5, 0.75, 1.0],      //每种颜色所占的比例，总数为2，多出部分被初始颜色覆盖</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>扇形渐变每种颜色的基准线为改颜色的中心线（不理解的自己试一下就知道了）。<br><code>tileMode</code>是这三种渐变都有的属性，不仅限于线性渐变。<br>径向渐变、扇形渐变的圆心位置和线性渐变的起始/结束坐标都是可以设置具体数值的。</p>
<h4 id="backgroundBlendMode"><a href="#backgroundBlendMode" class="headerlink" title="backgroundBlendMode"></a>backgroundBlendMode</h4><p>图像混合模式，这个东西有点多，要单开一篇。</p>
<h4 id="shape"><a href="#shape" class="headerlink" title="shape"></a>shape</h4><p>当前Container的形状</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">decoration: BoxDecoration(</span><br><span class="line">  shape: BoxShape.rectangle</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>有两个值<br><code>rectangle</code>：矩形<br><code>circle</code>：圆形，不会出现椭圆的情况，宽高不同时直径按小的那个值算。</p>
<h2 id="5、width-amp-height"><a href="#5、width-amp-height" class="headerlink" title="5、width &amp; height"></a>5、width &amp; height</h2><p>这俩放一起，<code>double</code>类型，宽高。</p>
<h2 id="6、constraints"><a href="#6、constraints" class="headerlink" title="6、constraints"></a>6、constraints</h2><p>对Container的尺寸约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constraints: new BoxConstraints(</span><br><span class="line">  minWidth: 200.0,</span><br><span class="line">  maxWidth: 300.0,</span><br><span class="line">  minHeight: 200.0,</span><br><span class="line">  maxHeight: 300.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="7、transform"><a href="#7、transform" class="headerlink" title="7、transform"></a>7、transform</h2><p>对Container进行变换操作，和css的transform类似，值是一个矩阵(Matrix4)。<br>这里暂时跳过，开一篇单独说。</p>
<h2 id="8、child"><a href="#8、child" class="headerlink" title="8、child"></a>8、child</h2><p>子节点，只能有一个子节点，没有children。</p>
<h2 id="9、关于Container的特性"><a href="#9、关于Container的特性" class="headerlink" title="9、关于Container的特性"></a>9、关于<code>Container</code>的特性</h2><h4 id="关于尺寸的自我调节"><a href="#关于尺寸的自我调节" class="headerlink" title="关于尺寸的自我调节"></a>关于尺寸的自我调节</h4><p>1、如果设置了<code>width/height/constraints</code>，并且尺寸小于父组件的尺寸，则为设置的宽高，如果大于父组件的尺寸则为父组件的宽高，如果父组件有<code>padding</code>，或当前组件有<code>margin</code>需要减去<code>padding/margin</code>。<br>2、如果没有子节点并且没有<code>width/height</code>以及<code>constraints</code>约束，Container的尺寸会撑到最大，尽可能占满父节点。<br>2、如果有子节点并且没有<code>width/height</code>以及<code>constraints</code>约束，Container会尽量缩小。</p>
<h4 id="关于渲染过程"><a href="#关于渲染过程" class="headerlink" title="关于渲染过程"></a>关于渲染过程</h4><p>生成节点：<br><code>padding &gt; decoration &gt; constraints (width/height) &gt; margin</code><br>绘制节点：<br><code>transform &gt; decoration &gt; foregroundDecoration</code></p>
<p><code>Container</code>差不多就这些东西，不是太深入，深入的东西就需要自己在项目或者demo中尝试了，还有一些即使是粗略的说也不少，放这里感觉不太合适，后边单独分析。</p>
]]></content>
  </entry>
  <entry>
    <title>hello world和文本组件Text、TextSpan</title>
    <url>/post/textWidget/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>代码的世界从<code>hello world</code>开始，flutter也一样。<br>创建一个项目，将<code>lib</code>文件夹下的<code>main.dart</code>改为如下代码：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;Flutter Demo&apos;,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">      body: new Center(</span><br><span class="line">        child: new Text(</span><br><span class="line">          &apos;hello world&apos;</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跑起来<br><img src="1.png" alt="image.png"><br><code>hello world</code>完成了。</p>
<p>先简单介绍两个组件</p>
<h3 id="1、Scaffold"><a href="#1、Scaffold" class="headerlink" title="1、Scaffold"></a>1、Scaffold</h3><p>打开任意一款app，顶部标题栏、侧边抽屉、底部导航等…，基本上都有这里边的一个或者几个，基于这个现状，material很贴心的提供了<code>scaffold</code>这个组件，相当于一个页面的骨架，可以把上边说的那些东西拼到里边。</p>
<h3 id="2、Center"><a href="#2、Center" class="headerlink" title="2、Center"></a>2、Center</h3><p>很简单的一句话，这个组件的子组件水平垂直居中。<br>这两个只是简单的介绍一下，以后再详细说，接下来是这篇笔记的主角。</p>
<h1 id="文本Widget"><a href="#文本Widget" class="headerlink" title="文本Widget"></a>文本Widget</h1><h2 id="一、Text"><a href="#一、Text" class="headerlink" title="一、Text"></a>一、Text</h2><p><code>hello world</code>这个demo里用过了，相当于<code>html</code>里边的<code>&lt;p&gt;&lt;/p&gt;</code>，但是又有所不同，都知道<code>p</code>标签独占一行，宽度如果没有限制则为父级宽度，<code>Text</code>也是独占一行，但是宽度为内容宽度，并且没有<code>width</code>属性。<br>看上边的demo，是不是感觉字体有点小，还想换个颜色，加个下划线…还有其他各种骚操作。<br>先看一下官网给出的Text</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Text(</span><br><span class="line">  String data,                                   //文本上边demo的hello world</span><br><span class="line">  &#123;</span><br><span class="line">    Key key,                                   //唯一标识，相当于react中map渲染节点的key</span><br><span class="line">    TextStyle style,                            //样式</span><br><span class="line">    StrutStyle strutStyle,                    //？？？不知道干啥的</span><br><span class="line">    TextAlign textAlign,                      //对齐方式</span><br><span class="line">    TextDirection textDirection,          //文本的书写顺序</span><br><span class="line">    Locale locale,                                //设置语言环境  就是国际化，多语言支持</span><br><span class="line">    bool softWrap,                              //文本过长是否自动换行</span><br><span class="line">    TextOverflow overflow,                  //对溢出文本的显示方式</span><br><span class="line">    double textScaleFactor,                //每个逻辑像素的字体像素数</span><br><span class="line">    int maxLines,                                //文本的最大行数</span><br><span class="line">    String semanticsLabel,                  //图像的语义描述，用于向Andoid上的TalkBack和iOS上的VoiceOver提供图像描述</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>接下来挨个看</p>
<h3 id="1、TextStyle"><a href="#1、TextStyle" class="headerlink" title="1、TextStyle"></a>1、TextStyle</h3><p>设置字体的样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const TextStyle(&#123;</span><br><span class="line">  bool inherit: true,                                  //是否继承父级</span><br><span class="line">  Color color,                                           //字体颜色</span><br><span class="line">  Color backgroundColor,                        //背景色</span><br><span class="line">  double fontSize,                                      //字体大小</span><br><span class="line">  FontWeight fontWeight,                          //字体粗细</span><br><span class="line">  FontStyle fontStyle,                                //正常/斜体</span><br><span class="line">  double letterSpacing,                              //字符间距可为负</span><br><span class="line">  double wordSpacing,                              //字间距（英文单词间距）</span><br><span class="line">  TextBaseline textBaseline,                        //文本对齐基线</span><br><span class="line">  Height height,                                          //Text的高度，相当于行高</span><br><span class="line">  Local locale,                                            //设置语言环境  就是国际化，多语言支持</span><br><span class="line">  Paint foreground,                                      //不知道是啥</span><br><span class="line">  Paint background,                                      //文本背景色作用和backgroundColor相同</span><br><span class="line">  List&lt;Shadow&gt; shadows,                            //文字阴影</span><br><span class="line">  TextDecoration decoration,                        //划线</span><br><span class="line">  Color decorationColor,                                //划线颜色</span><br><span class="line">  TextDecoration decorationStyle,                 //划线种类</span><br><span class="line">  double decorationThickness,                    //划线的粗细</span><br><span class="line">  String debugLabel,                                   //文本样式的文本描述，仅在debug模式下有效           </span><br><span class="line">  String fontFamily,</span><br><span class="line">  List&lt;String&gt; fontFamilyFallback,</span><br><span class="line">  String package,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接下来详解</p>
<h4 id="color"><a href="#color" class="headerlink" title="color"></a>color</h4><p>flutter的color支持5种写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style: TextStyle(</span><br><span class="line">  color: Color(0xFF42A5F5),                                            //十六进制色号两个F的位置为透明度，取值范围00～FF</span><br><span class="line">  color: Color.fromARGB(0xFF, 0x42, 0xA5, 0xF5),         //十六进制色号第一位为透明度，从00～FF</span><br><span class="line">  color: Color.fromARGB(255, 66, 165, 245),                   //十进制色号第一位为透明度，0~255</span><br><span class="line">  color: Color.fromRGBO(66, 165, 245, 1.0),                    //最后一位为透明度, 0.0~1.0</span><br><span class="line">  color: Colors.red                                                   //material内置</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="backgroundColor"><a href="#backgroundColor" class="headerlink" title="backgroundColor"></a>backgroundColor</h4><p>背景色和color的写法一样</p>
<h4 id="fontSize"><a href="#fontSize" class="headerlink" title="fontSize"></a>fontSize</h4><p>字体大小，double类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style: TextStyle(</span><br><span class="line">  fontSize: 30.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>不用写单位，flutter的单位是<code>dp</code>。</p>
<h4 id="letterSpacing"><a href="#letterSpacing" class="headerlink" title="letterSpacing"></a>letterSpacing</h4><p>字符间距</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style: TextStyle(</span><br><span class="line">  letterSpacing: 6.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="wordSpacing"><a href="#wordSpacing" class="headerlink" title="wordSpacing"></a>wordSpacing</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style: TextStyle(</span><br><span class="line">  wordSpacing: 10.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="textBaseline"><a href="#textBaseline" class="headerlink" title="textBaseline"></a>textBaseline</h4><p>对齐基线，类似css的基线，<code>alphabetic/ideographic</code>两个值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style: TextStyle(</span><br><span class="line">  textBaseline: TextBaseline.alphabetic</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>alphabetic：简单理解为英文的对齐基线<br>ideographic：简单理解为中文对齐基线</p>
<h4 id="height"><a href="#height" class="headerlink" title="height"></a>height</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style: TextStyle(</span><br><span class="line">  height: 1.5</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>和css一样1.5就是字体大小的1.5倍。</p>
<h4 id="background"><a href="#background" class="headerlink" title="background"></a>background</h4><p>这个注意了，不是<code>Color</code>，是<code>Paint</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style: TextStyle(</span><br><span class="line">  background: Paint() ..color = Colors.blue</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个和<code>backgroundColor</code>一样，两者不能共存。<br>..是<code>dart</code>语法糖，前一个函数的返回值的属性，说的有点绕，看代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Paint() ..color = Colors.blue;</span><br><span class="line">//下边代码的简写</span><br><span class="line">Paint pg = Paint();</span><br><span class="line">pg.color = Colors.blue;</span><br></pre></td></tr></table></figure>

<h4 id="shadows"><a href="#shadows" class="headerlink" title="shadows"></a>shadows</h4><p><code>List</code>类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style = TextStyle(</span><br><span class="line">  shadows: [Shadow(color: Colors.black,offset: Offset(5, 6),blurRadius: 3 )]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里说明一下参数<br><code>color</code>：阴影颜色，<br><code>offset</code>：两个参数xy方向的偏移量，<br><code>blurRadius</code>: 模糊程度</p>
<h4 id="decoration"><a href="#decoration" class="headerlink" title="decoration"></a>decoration</h4><p>和css的<code>text-decoration</code>类似</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style = TextStyle(</span><br><span class="line">  decoration: TextDecoration.underline</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>有5个值<br><code>underline</code>：下划线<br><code>none</code>：无划线<br><code>overline</code>：上划线<br><code>lineThrough</code>：中划线<br><code>combine</code>：这个就厉害了，可以传入一个<code>List</code>，三线齐划</p>
<h4 id="decorationColor"><a href="#decorationColor" class="headerlink" title="decorationColor"></a>decorationColor</h4><p>划线的颜色，默认和字体颜色相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style: TextStyle(</span><br><span class="line">  decorationColor:  Colors.black</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="decorationStyle"><a href="#decorationStyle" class="headerlink" title="decorationStyle"></a>decorationStyle</h4><p>默认为实线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style = TextStyle(</span><br><span class="line">  decorationStyle: TextDecorationStyle.dashed</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>dashed</code>：点划线<br><code>dotted</code>：虚线<br><code>double</code>：双划线<br><code>solid</code>：实线<br><code>wavy</code>：波浪线</p>
<h4 id="decorationThickness"><a href="#decorationThickness" class="headerlink" title="decorationThickness"></a>decorationThickness</h4><p>划线的粗细，默认为1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style = TextStyle(</span><br><span class="line">  decorationThickness: 3.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="debugLabel"><a href="#debugLabel" class="headerlink" title="debugLabel"></a>debugLabel</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">style = TextStyle(</span><br><span class="line">  debugLabel: &apos;test</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>加上之后没找到怎么看这个提示。。。</p>
<h3 id="2、strutStyle"><a href="#2、strutStyle" class="headerlink" title="2、strutStyle"></a>2、strutStyle</h3><p>看文档这个应该是<code>style</code>的简写，类似css里边的<code>background/font</code>这种，可以把样式写到一起，样式是有顺序的，这里不研究了，不推荐这种写法，可读性不高不好维护。</p>
<h3 id="3、textAlign"><a href="#3、textAlign" class="headerlink" title="3、textAlign"></a>3、textAlign</h3><p>对齐方式，和css的<code>text-align</code>基本上相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">textAlign: TextAlign.start</span><br></pre></td></tr></table></figure>

<p><code>start</code>：起始位置<br><code>end</code>：结束位置<br><code>center</code>：居中<br><code>left</code>：左对齐<br><code>right</code>：右对齐<br><code>justify</code>：两端对齐</p>
<h3 id="4、textDirection"><a href="#4、textDirection" class="headerlink" title="4、textDirection"></a>4、textDirection</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">textDirection: TextDirection.ltr</span><br></pre></td></tr></table></figure>

<p><code>ltr</code>：从左到右<br><code>rtl</code>：从右到左<br>left to right，right to left</p>
<h3 id="5、locale"><a href="#5、locale" class="headerlink" title="5、locale"></a>5、locale</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locale: Locale(&apos;fr&apos;, &apos;CH&apos;)</span><br></pre></td></tr></table></figure>

<p>这个不是添加了就会自动翻译，还要配置其他东西，以及第三方包，以后再详细说。</p>
<h3 id="6、softWrap"><a href="#6、softWrap" class="headerlink" title="6、softWrap"></a>6、softWrap</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">softWrap: true</span><br></pre></td></tr></table></figure>

<p>文本超出容器时是否自动换行，默认为<code>true</code>，为<code>false</code>时文本超出容器部分默认被剪切。</p>
<h3 id="7、overflow"><a href="#7、overflow" class="headerlink" title="7、overflow"></a>7、overflow</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">overflow: TextOverflow.clip</span><br></pre></td></tr></table></figure>

<p>对文本溢出部分的处理，类似css中的<code>overflow</code>。<br><code>clip</code>：切断，超出部分不显示，默认值<br><code>ellipsis</code>：超出部分不显示，显示…<br><code>visible</code>：超出部分强制显示<br><code>fade</code>：超出部分淡出</p>
<h3 id="8、textScaleFactor"><a href="#8、textScaleFactor" class="headerlink" title="8、textScaleFactor"></a>8、textScaleFactor</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">textScaleFactor: 1.5</span><br></pre></td></tr></table></figure>

<p>缩放的倍数</p>
<h3 id="9、maxLines"><a href="#9、maxLines" class="headerlink" title="9、maxLines"></a>9、maxLines</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxLines: 2</span><br></pre></td></tr></table></figure>

<p>文本的最大行数</p>
<p>####10、semanticsLabel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">semanticsLabel: &apos;test&apos;</span><br></pre></td></tr></table></figure>

<p>这个应该是相当于html中<code>img</code>的<code>alt</code>。<br>下面上完整代码，把上边demo中的<code>Center</code>换成<code>Container</code>（相当于html中的<code>div</code>，下篇笔记详细说），再加个<code>width</code>便于观察样式和属性对文本的改变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  // This widget is the root of your application.</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;Flutter Demo&apos;,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        body: new Container(</span><br><span class="line">          width: 400.0,</span><br><span class="line">          child: new Text(</span><br><span class="line">            &apos;hello world hello world hello world hello world hello world hello world&apos;,</span><br><span class="line">            style: TextStyle(</span><br><span class="line">              color: Color.fromARGB(0xFF, 0x42, 0xA5, 0xF5),</span><br><span class="line">              backgroundColor: Colors.red,</span><br><span class="line">              fontSize: 30.0,</span><br><span class="line">              letterSpacing: 6.0,</span><br><span class="line">              wordSpacing: 15.0,</span><br><span class="line">              height: 2.0,</span><br><span class="line">//              background: Paint() ..color = Colors.blue,</span><br><span class="line">              shadows: [Shadow(color: Colors.black,offset: Offset(5, 6),blurRadius: 3 )],</span><br><span class="line">              decoration: TextDecoration.combine([</span><br><span class="line">                TextDecoration.underline,</span><br><span class="line">                TextDecoration.overline</span><br><span class="line">              ]),</span><br><span class="line">              decorationColor: Colors.black,</span><br><span class="line">              decorationStyle: TextDecorationStyle.wavy,</span><br><span class="line">              decorationThickness: 3.0,</span><br><span class="line">              debugLabel: &apos;text&apos;</span><br><span class="line">            ),</span><br><span class="line">            textAlign: TextAlign.justify,</span><br><span class="line">            textDirection: TextDirection.rtl,</span><br><span class="line">            locale: Locale(&apos;fr&apos;, &apos;CH&apos;),</span><br><span class="line">            softWrap: true,</span><br><span class="line">            overflow: TextOverflow.visible,</span><br><span class="line">            textScaleFactor: 1.5,</span><br><span class="line">            maxLines: 2,</span><br><span class="line">            semanticsLabel: &apos;test&apos;</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学习的时候建议不要像这里一样加太多的样式和属性，不相关的属性或者样式先单独练习再组合，有的需要配合使用，比如溢出<code>softWrap</code>、<code>overflow</code>、<code>maxLines</code>这些。</p>
<h2 id="二、TextSpan"><a href="#二、TextSpan" class="headerlink" title="二、TextSpan"></a>二、TextSpan</h2><p>html里有个<code>span</code>这里有个<code>TextSpan</code>，作用基本相同，文字放一行，下面看代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  // This widget is the root of your application.</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;Flutter Demo&apos;,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        body: new Center(</span><br><span class="line">          child: new Text.rich(</span><br><span class="line">            TextSpan(</span><br><span class="line">              children: [</span><br><span class="line">                new TextSpan(text: &apos;hello: &apos;),</span><br><span class="line">                new TextSpan(</span><br><span class="line">                  text: &apos;world&apos;,</span><br><span class="line">                  style: TextStyle(</span><br><span class="line">                    color: Colors.red</span><br><span class="line">                  )</span><br><span class="line">                )</span><br><span class="line">              ]</span><br><span class="line">            )</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果<br><img src="2.png" alt="image.png"><br><code>TextSpan</code>需要套一层<code>Text.rich</code>，可以有<code>children</code>，<code>children</code>同为<code>TextSpan</code>，可以分别加不同的样式，这里只能加样式，不可以加其他的属性。<br>文本组件到这里就结束了，如有遗漏欢迎补充，如有错误请指正。</p>
]]></content>
  </entry>
  <entry>
    <title>官方示例 &amp; 代码解读</title>
    <url>/post/officialExample/</url>
    <content><![CDATA[<p>语法的东西就不详细说了，可以看官方文档了解一下<a href="https://www.dartcn.com/" target="_blank" rel="noopener">https://www.dartcn.com/</a>，学习过程中也会介绍一些。</p>
<a id="more"></a>
<p>环境搭好，怎么搭看官网，很详细，并且为中国用户提供了解决方案</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter help</span><br></pre></td></tr></table></figure>

<p>可以看见官方提供的命令。接下来创建个项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter create mypp</span><br></pre></td></tr></table></figure>

<p>创建好之后进入<code>myapp</code>先看一下模拟器（android stidio里边自己下）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  myapp flutter emulators    //查看可用的模拟器</span><br></pre></td></tr></table></figure>

<p><img src="1.png" alt="image.png"><br>我这里有两个，运行android模拟器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜ flutter emulators --launch Nexus_5X_API_28</span><br></pre></td></tr></table></figure>

<p>模拟器跑起来之后，查看一下可用设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter devices</span><br></pre></td></tr></table></figure>

<p><img src="2.png" alt="image.png"><br>接下来把项目跑起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//只有一个可用设备</span><br><span class="line">flutter run</span><br><span class="line">//如果有多个设备需要指定id</span><br><span class="line">flutter run -d emulator-5554</span><br></pre></td></tr></table></figure>

<p><img src="3.png" alt="image.png"></p>
<p><img src="4.png" alt="image.png"><br>可以看到项目已经跑起来了<br>命令直接按<code>r</code>热重载，<code>R</code>重启项目。<br>按<code>h</code>可以查看更多命令。<br><img src="5.png" alt="image.png"><br>我们来看一下代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;  //引入material风格的ui库</span><br><span class="line"></span><br><span class="line">//每个dart项目都要有一个main函数</span><br><span class="line">//void表示空类型，写到函数前边代表这个函数没有返回值</span><br><span class="line">//这里用了dart语法的箭头函数</span><br><span class="line">void main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line">//main函数跑的MyApp在这里定义  继承了无状态Widget（相当于react的组件）</span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  @override    //@元数据  为代码添加额外的信息  @override代表下边这个是一个覆写超类的函数</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;Flutter Demo&apos;,</span><br><span class="line">      //app的主题</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        //这里给了蓝色，可以改成red、green、yellow等其他颜色然后在命令行按r看一下效果</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      //路由主页</span><br><span class="line">      home: MyHomePage(title: &apos;Flutter Demo Home Page&apos;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建主页  这是一个有状态组件</span><br><span class="line">class MyHomePage extends StatefulWidget &#123;</span><br><span class="line">  //接收一个参数title</span><br><span class="line">  MyHomePage(&#123;Key key, this.title&#125;) : super(key: key);</span><br><span class="line">  final String title;</span><br><span class="line">  //有状态组件还需要一个State类</span><br><span class="line">  @override</span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//有状态组件的State类</span><br><span class="line">class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;</span><br><span class="line">  //状态</span><br><span class="line">  int _counter = 0;</span><br><span class="line">  //声明一个改变状态的函数</span><br><span class="line">  void _incrementCounter() &#123;</span><br><span class="line">    //和react的setState作用一样</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    //这里有个Scaffold组件，先不用管干啥的，介绍组件的时候会详细介绍</span><br><span class="line">    return Scaffold(</span><br><span class="line">      //主页的标题栏</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        //传入的title</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      //主页内容，Center组件里边的内容水平垂直居中，以后再详细介绍</span><br><span class="line">      body: Center(</span><br><span class="line">        //Column的子组件垂直排列</span><br><span class="line">        child: Column(</span><br><span class="line">          //主轴上的对其方式，这里是居中</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          //多个子组件用children，单个子组件用child（有child的组件，不一定有children，有的组件只可以有一个子组件）</span><br><span class="line">          //这里是一个泛型数组里只能放Widget</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            //文本组件，可以设置文字样式</span><br><span class="line">            Text(</span><br><span class="line">              &apos;You have pushed the button this many times:&apos;,</span><br><span class="line">            ),</span><br><span class="line">            Text(</span><br><span class="line">              //相当于js里边的`$&#123;_counter&#125;`</span><br><span class="line">              &apos;$_counter&apos;,</span><br><span class="line">              //文本样式</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      //ui库提供的浮动按钮</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        //长按提示</span><br><span class="line">        tooltip: &apos;Increment&apos;,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>差不多就这些东西吧，详细的东西放到后边，这里先介绍一下结构。</p>
]]></content>
  </entry>
  <entry>
    <title>花瓣飘落效果</title>
    <url>/post/petalsFluttered/</url>
    <content><![CDATA[<p>先上效果：<a href="https://monkeyinwind.github.io/canvaspetal/index.html" target="_blank" rel="noopener">https://monkeyinwind.github.io/canvaspetal/index.html</a><br>github：<a href="https://github.com/MonkeyInWind/canvaspetal" target="_blank" rel="noopener">https://github.com/MonkeyInWind/canvaspetal</a></p>
<a id="more"></a>
<p>这个demo写了很久了，今天有时间简单写一下过程。<br>用了react，这个不重要，随便用什么环境都可以。<br>首先花瓣要有素材，随便搜了一下，切了几个出来。</p>
<p><img src="1.png" alt="image.png"></p>
<h1 id="1、在页面上添加一个canvas"><a href="#1、在页面上添加一个canvas" class="headerlink" title="1、在页面上添加一个canvas"></a>1、在页面上添加一个canvas</h1><p>整个页面只有一个canvas，我们需要这个canvas占满整个浏览器可视区，并且在浏览器窗口改变大小的时候依然和可视区大小相同，同时给canvas加个背景色。<br><img src="2.png" alt="image.png"><br>这一步很简单没有什么需要说的。</p>
<h1 id="2、在canvas上画一个花瓣"><a href="#2、在canvas上画一个花瓣" class="headerlink" title="2、在canvas上画一个花瓣"></a>2、在canvas上画一个花瓣</h1><p>创建一个<code>createPetal</code>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.src = require(&quot;./images/petal1.png&quot;);</span><br><span class="line">    img.onload = () =&gt; &#123;</span><br><span class="line">      ctx.drawImage(img, 100, 100);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>componentDidMount</code>调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    this.setCanvas();</span><br><span class="line">    window.onresize = this.setCanvas;</span><br><span class="line">    this.createPetal();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这样就在<code>100， 100</code>这个位置画了个花瓣<br><img src="3.png" alt="image.png"></p>
<h1 id="3、让这个花瓣动起来"><a href="#3、让这个花瓣动起来" class="headerlink" title="3、让这个花瓣动起来"></a>3、让这个花瓣动起来</h1><p>canvas动画是高频率刷新，清空上一帧，画下一帧，看起来是动画。<br>了解了动画的原理，接下来就可以开始写动画，首先将坐标放到<code>state</code>中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0,</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建一个<code>go</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go(ctx, img) &#123;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x: this.state.x + 1,</span><br><span class="line">      y: this.state.y + 1</span><br><span class="line">    &#125;);//移动花瓣坐标</span><br><span class="line">    ctx.drawImage(img, this.state.x, this.state.y);</span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>createPetal</code>中调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.src = require(&quot;./images/petal1.png&quot;);</span><br><span class="line">    img.onload = () =&gt; &#123;</span><br><span class="line">      ctx.drawImage(img, this.state.x, this.state.y);</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>接下来可以看到效果。<br><img src="4.gif" alt="Feb-03-2019 10-16-19.gif"><br>录的有点卡，实际上要比这个效果好很多。。。<br>有没有发现问题，花瓣位置超出浏览器之后去哪了打印一下坐标。<br><img src="5.png" alt="image.png"><br>可以看到还在继续飘，这不是想要的，所以在坐标超出浏览器之后让它回到初始位置。<br><code>go</code>这个函数修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go(ctx, img) &#123;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    let x = this.state.x + 1;</span><br><span class="line">    let y = this.state.y + 1;</span><br><span class="line">    if (x &gt; this.state.cw || y &gt; this.state.ch) &#123;</span><br><span class="line">      x = 0;</span><br><span class="line">      y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x,</span><br><span class="line">      y</span><br><span class="line">    &#125;);//移动花瓣坐标</span><br><span class="line">    ctx.drawImage(img, this.state.x, this.state.y);</span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>看一下效果<br><img src="6.gif" alt="Feb-03-2019 10-24-14.gif"></p>
<p>这一步实现之后，有没有发现还有问题，要模拟自然飘落，这个花瓣不可能没有旋转，接下来再加上旋转。<br>这个旋转，需要的是画布旋转，旋转画好了之后再复位。<br>在<code>state</code>中加上旋转角度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0,</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">      r: 0   //旋转角度</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>go</code>里面加上旋转，并且为了统一动作和计算方便，这里将图片位移改为画布位移，画图坐标相对画布始终在同一位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go(ctx, img) &#123;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    let x = this.state.x + 1;</span><br><span class="line">    let y = this.state.y + 1;</span><br><span class="line">    let r = this.state.r + 0.1;</span><br><span class="line">    if (x &gt; this.state.cw || y &gt; this.state.ch) &#123;</span><br><span class="line">      x = 0;</span><br><span class="line">      y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x,</span><br><span class="line">      y,</span><br><span class="line">      r</span><br><span class="line">    &#125;);//移动花瓣坐标</span><br><span class="line">    ctx.save();//保存画布当前状态</span><br><span class="line">    ctx.translate(this.state.x, this.state.y); //改为画布位移</span><br><span class="line">    ctx.rotate(this.state.r);   //画布旋转</span><br><span class="line">    ctx.drawImage(img, 0, 0);  //画图坐标始终在画布左上角</span><br><span class="line">    ctx.restore();</span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="7.gif" alt="Feb-03-2019 10-48-19.gif"><br>和预想的不太一样，这是因为画布默认的旋转中心为左上角，<br>我们需要将旋转中心移到图片的中心。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go(ctx, img) &#123;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    let w = img.width;</span><br><span class="line">    let h = img.height;</span><br><span class="line">    let x = this.state.x + 1;</span><br><span class="line">    let y = this.state.y + 1;</span><br><span class="line">    let r = this.state.r + 0.1;</span><br><span class="line">    if (x &gt; this.state.cw || y &gt; this.state.ch) &#123;</span><br><span class="line">      x = 0;</span><br><span class="line">      y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x,</span><br><span class="line">      y,</span><br><span class="line">      r</span><br><span class="line">    &#125;);//移动花瓣坐标</span><br><span class="line">    ctx.save();//保存画布当前状态</span><br><span class="line">    ctx.translate(this.state.x + w / 2, this.state.y + h / 2); //改为画布位移</span><br><span class="line">    ctx.rotate(this.state.r);</span><br><span class="line">    ctx.drawImage(img, -w / 2, - h / 2);  //画图坐标始终在画布左上角</span><br><span class="line">    ctx.restore();</span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>看一下效果<br><img src="8.gif" alt="Feb-03-2019 10-55-18.gif"><br>旋转是有了，<br>但是好像不太对，只绕Z轴旋转，要让它变成3D旋转，这里要用到缩放<code>scale</code>，缩放这里不可能一直放大或者缩小，所以还要加一个变量控制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0,</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">      r: 0,</span><br><span class="line">      scale: 1,</span><br><span class="line">      toLarge: true</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来将<code>go</code>改一下，加上<code>scale</code>并且旋转速度调整一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go(ctx, img) &#123;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    let w = img.width;</span><br><span class="line">    let h = img.height;</span><br><span class="line">    let x = this.state.x + 1;</span><br><span class="line">    let y = this.state.y + 1;</span><br><span class="line">    let r = this.state.r + 0.05;</span><br><span class="line">    let scale = this.state.scale;</span><br><span class="line">    let toLarge = this.state.toLarge;</span><br><span class="line"></span><br><span class="line">    if (scale &gt;= 1) &#123;</span><br><span class="line">      toLarge = false;</span><br><span class="line">    &#125; else if (scale &lt;= 0) &#123;</span><br><span class="line">      toLarge = true;</span><br><span class="line">    &#125;//这里根据scale大小设置toLarge</span><br><span class="line"></span><br><span class="line">    if (toLarge) &#123;</span><br><span class="line">      scale += 0.01;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      scale -= 0.01;</span><br><span class="line">    &#125;//这里根据toLarge更改scale值</span><br><span class="line">    if (x &gt; this.state.cw || y &gt; this.state.ch) &#123;</span><br><span class="line">      x = 0;</span><br><span class="line">      y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x,</span><br><span class="line">      y,</span><br><span class="line">      r,</span><br><span class="line">      scale,</span><br><span class="line">      toLarge</span><br><span class="line">    &#125;);//移动花瓣坐标</span><br><span class="line">    ctx.save();//保存画布当前状态</span><br><span class="line">    ctx.translate(this.state.x + w / 2, this.state.y + h / 2); //改为画布位移</span><br><span class="line">    ctx.rotate(this.state.r);</span><br><span class="line">    ctx.scale(1, this.state.scale);</span><br><span class="line">    ctx.drawImage(img, -w / 2, - h / 2);  //画图坐标始终在画布左上角</span><br><span class="line">    ctx.restore();</span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>看一下效果<br><img src="9.gif" alt="Feb-03-2019 11-13-14.gif"><br>至此一个花瓣就写完了。<br>但是我们想要的是很多个花瓣同时飘。<br>这就需要一个花瓣的类。</p>
<h1 id="4、创建一个花瓣的class"><a href="#4、创建一个花瓣的class" class="headerlink" title="4、创建一个花瓣的class"></a>4、创建一个花瓣的class</h1><p>新建一个<code>petal.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Petal &#123;</span><br><span class="line">  constructor(w, h) &#123;</span><br><span class="line">    this.canvasW = w;  //canvas宽</span><br><span class="line">    this.canvasH = h;  //canvas高</span><br><span class="line">    this.w = 0;        //花瓣宽</span><br><span class="line">    this.h = 0;        //花瓣高</span><br><span class="line">    this.x = 0;        //初始x坐标</span><br><span class="line">    this.y = 0;        //初始y坐标</span><br><span class="line">    this.r = 0;        //初始旋转角度</span><br><span class="line">    this.scale = 1;    //初始缩放</span><br><span class="line">    this.toLarge = false;   //默认放大为false</span><br><span class="line">    this.speedX = 1;   //x方向速度</span><br><span class="line">    this.speedY = 1;   //y方向速度</span><br><span class="line">    this.speedScale= 0.01  //缩放速度</span><br><span class="line">    this.speedR = 0.05    //旋转速度</span><br><span class="line">  &#125;</span><br><span class="line">  //数据初始化，用于当花瓣超出浏览器可视区时重置位置</span><br><span class="line">  init() &#123;</span><br><span class="line">    this.x = 0;</span><br><span class="line">    this.y = 0;</span><br><span class="line">    this.r = 0;</span><br><span class="line">    this.scale = 1;</span><br><span class="line">    this.speedX = 1;</span><br><span class="line">    this.speedY = 1;</span><br><span class="line">    this.speedScale = 0.01;</span><br><span class="line">    this.speedR = 0.05;</span><br><span class="line">  &#125;</span><br><span class="line">  //画布位移、画图、画布复位</span><br><span class="line">  draw(ctx, img) &#123;</span><br><span class="line">    this.w = img.width;</span><br><span class="line">    this.h = img.height;</span><br><span class="line">    ctx.save();     //保存当前画布状态</span><br><span class="line">    ctx.translate(this.x + this.w / 2,  this.y + this.h / 2);  //画布位移</span><br><span class="line">    ctx.rotate(this.r);   //画布旋转</span><br><span class="line">    ctx.scale(1, this.scale);  //画布缩放</span><br><span class="line">    ctx.drawImage(img, -this.w / 2, -this.h / 2);   //画图</span><br><span class="line">    ctx.restore();    //画布复位</span><br><span class="line">  &#125;</span><br><span class="line">  //计算坐标</span><br><span class="line">  move() &#123;</span><br><span class="line">    this.x += this.speedX;</span><br><span class="line">    this.y += this.speedY;</span><br><span class="line">    this.r += this.speedR;</span><br><span class="line">    if (this.scale &gt;= 1) &#123;</span><br><span class="line">      this.toLarge = false;</span><br><span class="line">    &#125; else if (this.scale &lt;= 0) &#123;</span><br><span class="line">      this.toLarge = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.toLarge) &#123;</span><br><span class="line">      this.scale += this.speedScale;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.scale -= this.speedScale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.x &gt;= this.canvasW || this.y &gt;= this.canvasH) &#123;</span><br><span class="line">      this.init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>App.js</code>内引入并new一个花瓣，打印一下；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import Petal from &apos;./petal&apos;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0,</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">      r: 0,</span><br><span class="line">      scale: 1,</span><br><span class="line">      toLarge: true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.setCanvas = this.setCanvas.bind(this);</span><br><span class="line">    this.componentDidMount = this.componentDidMount.bind(this);</span><br><span class="line">    this.createPetal = this.createPetal.bind(this);</span><br><span class="line">    this.go = this.go.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setCanvas() &#123;</span><br><span class="line">    let W = document.documentElement.clientWidth;</span><br><span class="line">    let H = document.documentElement.clientHeight;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      cw: W,</span><br><span class="line">      ch: H</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.src = require(&quot;./images/petal1.png&quot;);</span><br><span class="line">    img.onload = () =&gt; &#123;</span><br><span class="line">      //ctx.drawImage(img, this.state.x, this.state.y);</span><br><span class="line">      // this.go(ctx, img);</span><br><span class="line">      let petal = new Petal(this.state.cw, this.state.ch);</span><br><span class="line">      console.log(petal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(ctx, img) &#123;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    let w = img.width;</span><br><span class="line">    let h = img.height;</span><br><span class="line">    let x = this.state.x + 1;</span><br><span class="line">    let y = this.state.y + 1;</span><br><span class="line">    let r = this.state.r + 0.05;</span><br><span class="line">    let scale = this.state.scale;</span><br><span class="line">    let toLarge = this.state.toLarge;</span><br><span class="line"></span><br><span class="line">    if (scale &gt;= 1) &#123;</span><br><span class="line">      toLarge = false;</span><br><span class="line">    &#125; else if (scale &lt;= 0) &#123;</span><br><span class="line">      toLarge = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (toLarge) &#123;</span><br><span class="line">      scale += 0.01;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      scale -= 0.01;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &gt; this.state.cw || y &gt; this.state.ch) &#123;</span><br><span class="line">      x = 0;</span><br><span class="line">      y = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      x,</span><br><span class="line">      y,</span><br><span class="line">      r,</span><br><span class="line">      scale,</span><br><span class="line">      toLarge</span><br><span class="line">    &#125;);//移动花瓣坐标</span><br><span class="line">    ctx.save();//保存画布当前状态</span><br><span class="line">    ctx.translate(this.state.x + w / 2, this.state.y + h / 2); //改为画布位移</span><br><span class="line">    ctx.rotate(this.state.r);</span><br><span class="line">    ctx.scale(1, this.state.scale);</span><br><span class="line">    ctx.drawImage(img, -w / 2, - h / 2);  //画图坐标始终在画布左上角</span><br><span class="line">    ctx.restore();</span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.setCanvas();</span><br><span class="line">    window.onresize = this.setCanvas;</span><br><span class="line">    this.createPetal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;canvas id=&quot;canvas&quot; ref=&quot;canvas&quot; width=&#123;this.state.cw&#125; height=&#123;this.state.ch&#125;&gt;&lt;/canvas&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p><img src="10.png" alt="image.png"><br>可以看见已经创建了一个初始的花瓣，暂时还没有画图片。<br>接下来就是把之前的go改一下，画上花瓣并动起来。<br><code>App.js</code>更改后如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import Petal from &apos;./petal&apos;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.setCanvas = this.setCanvas.bind(this);</span><br><span class="line">    this.componentDidMount = this.componentDidMount.bind(this);</span><br><span class="line">    this.createPetal = this.createPetal.bind(this);</span><br><span class="line">    this.go = this.go.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setCanvas() &#123;</span><br><span class="line">    let W = document.documentElement.clientWidth;</span><br><span class="line">    let H = document.documentElement.clientHeight;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      cw: W,</span><br><span class="line">      ch: H</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    let img = new Image();</span><br><span class="line">    img.src = require(&quot;./images/petal1.png&quot;);</span><br><span class="line">    img.onload = () =&gt; &#123;</span><br><span class="line">      let petal = new Petal(this.state.cw, this.state.ch);</span><br><span class="line">      this.go(ctx, petal, img);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(ctx, petal, img) &#123;</span><br><span class="line">    let W = this.state.cw;</span><br><span class="line">    let H = this.state.ch;</span><br><span class="line">    //浏览器窗口改变大小时同步更新petal的cnavas宽高值，与花瓣坐标对比判断是否在可视区内</span><br><span class="line">    petal.canvasW = W;</span><br><span class="line">    petal.canvasH = H;</span><br><span class="line">    ctx.clearRect(0, 0, this.state.cw, this.state.ch);//清空画布</span><br><span class="line">    petal.move();</span><br><span class="line">    petal.draw(ctx, img);</span><br><span class="line"></span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, petal, img);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.setCanvas();</span><br><span class="line">    window.onresize = this.setCanvas;</span><br><span class="line">    this.createPetal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;canvas id=&quot;canvas&quot; ref=&quot;canvas&quot; width=&#123;this.state.cw&#125; height=&#123;this.state.ch&#125;&gt;&lt;/canvas&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<h1 id="5、很多花瓣"><a href="#5、很多花瓣" class="headerlink" title="5、很多花瓣"></a>5、很多花瓣</h1><p>一个花瓣已经完成了，接下来就是很多个花瓣。<br>这里涉及到几个点：<br>1、img的src不能用变量，所以要用字符串拼接变量的形式。<br>2、一个花瓣用了onload，很多花瓣很明显一个onload已经不能满足了，这里用<code>promise.all</code>。<br>3、创建很多花瓣，并不是每次<code>drawImage</code>都需要<code>clearRect</code>，需要在第0个画之前清空canvas。<br>4、关于初始坐标和初始速度，很多个花瓣就需要随机坐标和随机速度，而且初始化所在的区域需要计算，否则会出现花瓣位移过程中不经过浏览器可视区或者分布不均。</p>
<h5 id="img的src"><a href="#img的src" class="headerlink" title="img的src"></a>img的src</h5><p>在<code>state</code>里加上花瓣数组，这里不能带后缀。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0,</span><br><span class="line">      n: 60,   //所要创建的花瓣数量</span><br><span class="line">      imgnames: [</span><br><span class="line">        &quot;petal1&quot;,</span><br><span class="line">        &quot;petal2&quot;,</span><br><span class="line">        &quot;petal3&quot;,</span><br><span class="line">        &quot;petal4&quot;,</span><br><span class="line">        &quot;petal5&quot;,</span><br><span class="line">        &quot;petal6&quot;,</span><br><span class="line">        &quot;petal7&quot;,</span><br><span class="line">        &quot;petal8&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>createPetal</code>函数改一下，创建多个img：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    // let img = new Image();</span><br><span class="line">    // img.src = require(&quot;./images/petal1.png&quot;);</span><br><span class="line">    let totalNum = this.state.imgnames.length; //图片的总数量</span><br><span class="line">    for (let i = 0; i &lt; this.state.n; i++) &#123;</span><br><span class="line">      let imgname = this.state.imgnames[i % totalNum];</span><br><span class="line">      let img = new Image();</span><br><span class="line">      img.src = require(`./images/$&#123;imgname&#125;.png`);</span><br><span class="line">      console.log(img)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // img.onload = () =&gt; &#123;</span><br><span class="line">      // let petal = new Petal(this.state.cw, this.state.ch);</span><br><span class="line">      // this.go(ctx, petal, img);</span><br><span class="line">    // &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>打印出60个img，src为base64；</p>
<h5 id="所有图片onload"><a href="#所有图片onload" class="headerlink" title="所有图片onload"></a>所有图片onload</h5><p>这里把单个img的load封装为<code>promise</code>，添加到一个数组里，然后用<code>promise.all</code><br>新建一个<code>imgLoad</code>函数，返回一个load的<code>promise</code>;<br>新建一个allImgLoad函数，用于返回一个<code>promise.all</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imgLoad(imgname) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        let img = new Image();</span><br><span class="line">        img.src = require(`./images/$&#123;imgname&#125;.png`);</span><br><span class="line">        img.onload = () =&gt; &#123;</span><br><span class="line">          resolve(img);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch(e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  allImgLoad(imgnames) &#123;</span><br><span class="line">    let p = [];</span><br><span class="line">    for(let i = 0; i &lt; imgnames.length; i++) &#123;</span><br><span class="line">      p.push(this.imgLoad(imgnames[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.all(p).then(res =&gt; &#123;</span><br><span class="line">      return res;</span><br><span class="line">    &#125;).catch((e) =&gt; &#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    // let img = new Image();</span><br><span class="line">    // img.src = require(&quot;./images/petal1.png&quot;);</span><br><span class="line">    let imgnames = [];</span><br><span class="line">    let totalNum = this.state.imgnames.length; //图片的总数量</span><br><span class="line">    for (let i = 0; i &lt; this.state.n; i++) &#123;</span><br><span class="line">      let imgname = this.state.imgnames[i % totalNum];</span><br><span class="line">      imgnames.push(imgname);</span><br><span class="line">    &#125;</span><br><span class="line">    let imgs = await this.allImgLoad(imgnames);</span><br><span class="line">    console.log(imgs)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到打印出了60个img<br><img src="11.png" alt="image.png"></p>
<h5 id="很多花瓣"><a href="#很多花瓣" class="headerlink" title="很多花瓣"></a>很多花瓣</h5><p>每一帧画60个花瓣，并且在第0个画之前清空画布，如果每画一个都清空一次，会把前59个都清空，画布上只有最后一个。<br>在<code>Petal</code>类里边的<code>move</code>和<code>init</code>用异步，加个<code>async</code>，否则会出现有的花瓣跳帧或者init的时候花瓣突然出现在屏幕上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Petal &#123;</span><br><span class="line">  constructor(w, h) &#123;</span><br><span class="line">    this.canvasW = w;  //canvas宽</span><br><span class="line">    this.canvasH = h;  //canvas高</span><br><span class="line">    this.w = 0;        //花瓣宽</span><br><span class="line">    this.h = 0;        //花瓣高</span><br><span class="line">    this.x = 0;        //初始x坐标</span><br><span class="line">    this.y = 0;        //初始y坐标</span><br><span class="line">    this.r = 0;        //初始旋转角度</span><br><span class="line">    this.scale = 1;    //初始缩放</span><br><span class="line">    this.toLarge = false;   //默认放大为false</span><br><span class="line">    this.speedX = 1;   //x方向速度</span><br><span class="line">    this.speedY = 1;   //y方向速度</span><br><span class="line">    this.speedScale= 0.01  //缩放速度</span><br><span class="line">    this.speedR = 0.05    //旋转速度</span><br><span class="line">  &#125;</span><br><span class="line">  //数据初始化，用于当花瓣超出浏览器可视区时重置位置</span><br><span class="line">  async init() &#123;</span><br><span class="line">    this.x = 0;</span><br><span class="line">    this.y = 0;</span><br><span class="line">    this.r = 0;</span><br><span class="line">    this.scale = 1;</span><br><span class="line">    this.speedX = 1;</span><br><span class="line">    this.speedY = 1;</span><br><span class="line">    this.speedScale = 0.01;</span><br><span class="line">    this.speedR = 0.05;</span><br><span class="line">  &#125;</span><br><span class="line">  //画布位移、画图、画布复位</span><br><span class="line">  draw(ctx, img) &#123;</span><br><span class="line">    this.w = img.width;</span><br><span class="line">    this.h = img.height;</span><br><span class="line">    ctx.save();     //保存当前画布状态</span><br><span class="line">    ctx.translate(this.x + this.w / 2,  this.y + this.h / 2);  //画布位移</span><br><span class="line">    ctx.rotate(this.r);   //画布旋转</span><br><span class="line">    ctx.scale(1, this.scale);  //画布缩放</span><br><span class="line">    ctx.drawImage(img, -this.w / 2, -this.h / 2);   //画图</span><br><span class="line">    ctx.restore();    //画布复位</span><br><span class="line">  &#125;</span><br><span class="line">  //计算坐标</span><br><span class="line">  async move() &#123;</span><br><span class="line">    this.x += this.speedX;</span><br><span class="line">    this.y += this.speedY;</span><br><span class="line">    this.r += this.speedR;</span><br><span class="line">    if (this.scale &gt;= 1) &#123;</span><br><span class="line">      this.toLarge = false;</span><br><span class="line">    &#125; else if (this.scale &lt;= 0) &#123;</span><br><span class="line">      this.toLarge = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.toLarge) &#123;</span><br><span class="line">      this.scale += this.speedScale;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.scale -= this.speedScale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.x &gt;= this.canvasW || this.y &gt;= this.canvasH) &#123;</span><br><span class="line">      await this.init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import Petal from &apos;./petal&apos;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.state = &#123;</span><br><span class="line">      cw: 0,</span><br><span class="line">      ch: 0,</span><br><span class="line">      n: 60,</span><br><span class="line">      imgnames: [</span><br><span class="line">        &quot;petal1&quot;,</span><br><span class="line">        &quot;petal2&quot;,</span><br><span class="line">        &quot;petal3&quot;,</span><br><span class="line">        &quot;petal4&quot;,</span><br><span class="line">        &quot;petal5&quot;,</span><br><span class="line">        &quot;petal6&quot;,</span><br><span class="line">        &quot;petal7&quot;,</span><br><span class="line">        &quot;petal8&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.setCanvas = this.setCanvas.bind(this);</span><br><span class="line">    this.componentDidMount = this.componentDidMount.bind(this);</span><br><span class="line">    this.createPetal = this.createPetal.bind(this);</span><br><span class="line">    this.go = this.go.bind(this);</span><br><span class="line">    this.imgLoad = this.imgLoad.bind(this);</span><br><span class="line">    this.allImgLoad = this.allImgLoad.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setCanvas() &#123;</span><br><span class="line">    let W = document.documentElement.clientWidth;</span><br><span class="line">    let H = document.documentElement.clientHeight;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      cw: W,</span><br><span class="line">      ch: H</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  imgLoad(imgname) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        let img = new Image();</span><br><span class="line">        img.src = require(`./images/$&#123;imgname&#125;.png`);</span><br><span class="line">        img.onload = () =&gt; &#123;</span><br><span class="line">          resolve(img);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch(e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  allImgLoad(imgnames) &#123;</span><br><span class="line">    let p = [];</span><br><span class="line">    for(let i = 0; i &lt; imgnames.length; i++) &#123;</span><br><span class="line">      p.push(this.imgLoad(imgnames[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.all(p).then(res =&gt; &#123;</span><br><span class="line">      return res;</span><br><span class="line">    &#125;).catch((e) =&gt; &#123;</span><br><span class="line">      console.log(e);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async createPetal() &#123;</span><br><span class="line">    let canvas = this.refs[&quot;canvas&quot;];</span><br><span class="line">    let ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">    let imgnames = [];</span><br><span class="line">    let totalNum = this.state.imgnames.length; //图片的总数量</span><br><span class="line">    for (let i = 0; i &lt; this.state.n; i++) &#123;</span><br><span class="line">      let imgname = this.state.imgnames[i % totalNum];</span><br><span class="line">      imgnames.push(imgname);</span><br><span class="line">    &#125;</span><br><span class="line">    let imgs = await this.allImgLoad(imgnames);</span><br><span class="line">    if(!imgs) return;</span><br><span class="line">    for(let i = 0; i &lt; imgs.length; i++) &#123;</span><br><span class="line">      let petal = new Petal(canvas.width, canvas.height);</span><br><span class="line">      this.go(ctx, petal, imgs[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async go(ctx, petal, img, index) &#123;</span><br><span class="line">    let W = this.state.cw;</span><br><span class="line">    let H = this.state.ch;</span><br><span class="line">    //浏览器窗口改变大小时同步更新petal的cnavas宽高值，与花瓣坐标对比判断是否在可视区内</span><br><span class="line">    petal.canvasW = W;</span><br><span class="line">    petal.canvasH = H;</span><br><span class="line">    if( index === 0) &#123;</span><br><span class="line">      ctx.clearRect(0, 0, W, H);//清空画布</span><br><span class="line">    &#125;</span><br><span class="line">    await petal.move();</span><br><span class="line">    petal.draw(ctx, img);</span><br><span class="line"></span><br><span class="line">    window.requestAnimationFrame(() =&gt; &#123;</span><br><span class="line">      this.go(ctx, petal, img, index);</span><br><span class="line">    &#125;);//重复清空画布，移动坐标重新画花瓣这个动作。</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.setCanvas();</span><br><span class="line">    window.onresize = this.setCanvas;</span><br><span class="line">    this.createPetal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;canvas id=&quot;canvas&quot; ref=&quot;canvas&quot; width=&#123;this.state.cw&#125; height=&#123;this.state.ch&#125;&gt;&lt;/canvas&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p>这个时候60个花瓣叠在一起，看一下效果<br><img src="12.gif" alt="Feb-03-2019 14-34-22.gif"></p>
<h5 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h5><p>首先要确定一下花瓣初始化的随机区域，有以下几点要求。<br>1、除了打开页面或者刷新页面，可以出现在浏览器可视区，其他情况下要出现在可视区外，从可视区边缘飘进可视区。<br>2、花瓣移动的路径要经过可视区，并且不会出现在左下角或者右上角只有半个花瓣划过的情况，没有意义。<br>3、分布均匀</p>
<p>接下来就是具体实施，先画个图，便于理解。<br><img src="13.png" alt="image.png"></p>
<p>把浏览器45度向左上方平移，我们需要花瓣出现在两条红线之间的区域，并且当花瓣移出浏览器可视区之后，只能出现在蓝色斜线区域。<br>这里花瓣首先随机出现在整个大矩形里，如果出现在想要的区域外，我们做如下处理：<br><img src="14.png" alt="image.png"><br>这样可以保证所有花瓣都会经过浏览器可视区，左下角和右上角不会出现半个花瓣的情况，并且均匀分布整个浏览器可视区。<br>移动端同理这里就不画图了下面上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const randNum = (min, max) =&gt; &#123;</span><br><span class="line">  return Math.random() * (max - min) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const calculateXY = (w, h) =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let x = randNum(-h + 100, w - 100);</span><br><span class="line">    let y = randNum(-h + 100, h - 100);</span><br><span class="line">    let b = 60;   //这里是加一个偏移量，防止移出可视区后初始化位置时突然在可视区上边缘和做边缘出现。</span><br><span class="line">    if (w &gt;= h) &#123;</span><br><span class="line">      let a = w - h;</span><br><span class="line">      //坐标在canvas区域，移到左上方同canvas大小区域</span><br><span class="line">      if (x &gt; -b &amp;&amp; y &gt; -b) &#123;</span><br><span class="line">        x = randNum(-h + b, a - b);</span><br><span class="line">        y = randNum(-h + b, -b);</span><br><span class="line">      &#125; else if (x &gt; a - b &amp;&amp; y &lt; -(h - (x - a) + b)) &#123;</span><br><span class="line">        //坐标在canvas右上方三角形区域，飘落不经过canvas，移到正上方三角形区域</span><br><span class="line">        y = randNum(-(h - (x - a) + b), -b);</span><br><span class="line">      &#125; else if (x &lt; -b &amp;&amp; y &gt; h + x - b) &#123;</span><br><span class="line">        //坐标在canvas左下方三角形区域，飘落不经过canvas，移到正左方三角形区域</span><br><span class="line">        y = randNum(0, h + x - b);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      let a = h - w;</span><br><span class="line">      if (x &gt; -b &amp;&amp; y &gt; -b) &#123;</span><br><span class="line">        x = randNum(-w + b, -b);</span><br><span class="line">        y = randNum(-w + b, a - b);</span><br><span class="line">      &#125; else if (x &gt; -b &amp;&amp; y &lt; -(w - x) + b) &#123;</span><br><span class="line">        y = randNum(-(w - x) + b, -b);</span><br><span class="line">      &#125; else if (x &lt; -b &amp;&amp; y &gt; h - x - b) &#123;</span><br><span class="line">        y = randNum(a, h - x - b);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(&#123;x, y&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class Petal &#123;</span><br><span class="line">  constructor(w, h) &#123;</span><br><span class="line">    this.canvasW = w;</span><br><span class="line">    this.canvasH = h;</span><br><span class="line">    this.w = 0;</span><br><span class="line">    this.h = 0;</span><br><span class="line">    this.y = randNum(-h + 100, h - 100); //这里两个100是防止直接出现在可视区边缘半个直接飘出去了</span><br><span class="line">    this.x = randNum(-h + 100, w - 100);</span><br><span class="line">    this.r = Math.random();</span><br><span class="line">    this.scale = -Math.random();</span><br><span class="line">    this.toLarge = false;</span><br><span class="line">    this.speedX = Math.random() * 0.5 + 0.5;</span><br><span class="line">    this.speedY = this.speedX;</span><br><span class="line">    this.speedScale = Math.random() * 0.007;</span><br><span class="line">    this.speedR = Math.random() * 0.03;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw(ctx, img) &#123;</span><br><span class="line">    this.w = img.width;</span><br><span class="line">    this.h = img.height;</span><br><span class="line">    ctx.save();</span><br><span class="line">    ctx.translate(this.x + this.w / 2, this.y + this.h / 2);</span><br><span class="line">    ctx.rotate(this.r);</span><br><span class="line">    ctx.scale(1, this.scale);</span><br><span class="line">    ctx.drawImage(img, -this.w / 2, -this.h / 2);</span><br><span class="line">    ctx.restore();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async init() &#123;</span><br><span class="line">    let xy = await calculateXY(this.canvasW, this.canvasH);</span><br><span class="line">    this.x = xy.x;</span><br><span class="line">    this.y = xy.y;</span><br><span class="line">    this.r = Math.random();</span><br><span class="line">    this.scale = -Math.random();</span><br><span class="line">    this.speedX = Math.random() * 0.5 + 0.3;</span><br><span class="line">    this.speedY = this.speedX;</span><br><span class="line">    this.speedScale = Math.random() * 0.004;</span><br><span class="line">    this.speedR = Math.random() * 0.03;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async move() &#123;</span><br><span class="line">    this.x += this.speedX;</span><br><span class="line">    this.y += this.speedY;</span><br><span class="line">    this.r += this.speedR;</span><br><span class="line">    if (this.scale &gt;= 1) &#123;</span><br><span class="line">      this.toLarge = false;</span><br><span class="line">    &#125; else if (this.scale &lt;= 0) &#123;</span><br><span class="line">      this.toLarge = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.toLarge) &#123;</span><br><span class="line">      this.scale += this.speedScale;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.scale -= this.speedScale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (this.x &gt;= this.canvasW || this.y &gt;= this.canvasH) &#123;</span><br><span class="line">      await this.init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就完成了，看一下帧数。<br>打开chrome开发者模式<br><img src="15.png" alt="image.png"><br>选<code>rendering</code>，勾选<code>FPS meter</code><br><img src="16.png" alt="image.png"><br>可以看到在60左右，是比较理想的<br><img src="17.png" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title>mac mysql8 密码</title>
    <url>/post/macMysql8Password/</url>
    <content><![CDATA[<p>新电脑安装mysql之后第一次是无法登陆的因为没有初始密码，网上都是老版本的处理方法，mysql8已经失效。</p>
<a id="more"></a>
<h3 id="1、停止mysql服务"><a href="#1、停止mysql服务" class="headerlink" title="1、停止mysql服务"></a>1、停止mysql服务</h3><p>系统设置偏好 &gt; mysql &gt; Stop Mysql Server<br><img src="1.png" alt="image.png"></p>
<h3 id="2、跳过登陆"><a href="#2、跳过登陆" class="headerlink" title="2、跳过登陆"></a>2、跳过登陆</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -i      //root权限</span><br><span class="line">sudo mysqld_safe --user=mysql --skip-grant-tables --skip-networking</span><br></pre></td></tr></table></figure>

<p><img src="2.png" alt="image.png"><br><code>这里不要动！！！</code><br>打开另一个终端窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root</span><br></pre></td></tr></table></figure>

<p>直接回车就可以登陆mysql</p>
<h3 id="3、修改密码"><a href="#3、修改密码" class="headerlink" title="3、修改密码"></a>3、修改密码</h3><p>在这里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>

<p>可以看见有个mysql数据库<br><img src="3.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">show tables;</span><br></pre></td></tr></table></figure>

<p>可以看见有个user的表，感兴趣可以看一下。<br>接下来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p><img src="4.png" alt="image.png"><br>重置密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;new password&apos;;</span><br></pre></td></tr></table></figure>

<p>关闭终端，重新打开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p[password]</span><br></pre></td></tr></table></figure>

<p>即可登陆mysql</p>
<h3 id="4、开机启动"><a href="#4、开机启动" class="headerlink" title="4、开机启动"></a>4、开机启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents/</span><br><span class="line">launchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>centos 安装mysql8 以及常用sql语句</title>
    <url>/post/centOsInstallMysql/</url>
    <content><![CDATA[<p>安装环境：centos7<br>刚租了台服务器安装mysql的时候发现之前的笔记已经不合适了，更新一下。</p>
<a id="more"></a>
<h4 id="mysql安装配置"><a href="#mysql安装配置" class="headerlink" title="mysql安装配置"></a>mysql安装配置</h4><p>1、检测是否安装过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure>

<p>2、删除当前已安装版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -e --nodeps `rpm -qa | grep mysql`</span><br></pre></td></tr></table></figure>

<p>3、在线安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install mysql-server</span><br></pre></td></tr></table></figure>

<p><code>这里可能会找不到包，如果没有可用的包，按照如下操作</code><br>去这里<a href="http://repo.mysql.com/" target="_blank" rel="noopener">http://repo.mysql.com/</a><br>选择最新版本的<code>mysql-community</code>的<code>rpm包</code>复制链接地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://repo.mysql.com/mysql80-community-release-el7-1.noarch.rpm</span><br><span class="line">rpm -ivh mysql80-community-release-el7-1.noarch.rpm</span><br><span class="line">yum -y install mysql-server</span><br></pre></td></tr></table></figure>

<p>4、开启mysql服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>

<p>5、mysql添加开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig mysqld on</span><br></pre></td></tr></table></figure>

<p>6、初始化配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &apos;temporary password&apos; /var/log/mysqld.log    //查看初始密码</span><br><span class="line">2018-12-04T14:08:38.524688Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: #Fwd;l5cl*r*   //初始密码  这很反人类</span><br><span class="line">//下面初始化</span><br><span class="line">whereis mysql_secure_installation    //找到mysql_secure_installation</span><br><span class="line">mysql_secure_installation: /usr/bin/mysql_secure_installation /usr/share/man/man1/mysql_secure_installation.1.gz</span><br><span class="line">/usr/bin/mysql_secure_installation    //直接运行mysql_secure_installation</span><br><span class="line">Securing the MySQL server deployment.</span><br><span class="line"></span><br><span class="line">Enter password for user root:            //输入刚才查看的密码</span><br><span class="line"></span><br><span class="line">The existing password for the user account root has expired. Please set a new password.</span><br><span class="line"></span><br><span class="line">New password:                              //新密码大小写数字加特殊符号</span><br><span class="line"></span><br><span class="line">Re-enter new password:              //重复新密码</span><br><span class="line">The &apos;validate_password&apos; component is installed on the server.</span><br><span class="line">The subsequent steps will run with the existing configuration</span><br><span class="line">of the component.</span><br><span class="line">Using existing password for root.</span><br><span class="line"></span><br><span class="line">Estimated strength of the password: 100</span><br><span class="line">Change the password for root ? ((Press y|Y for Yes, any other key for No) :        //直接跳过  选Y的话是重新设置密码</span><br><span class="line"> ... skipping.</span><br><span class="line">By default, a MySQL installation has an anonymous user,</span><br><span class="line">allowing anyone to log into MySQL without having to have</span><br><span class="line">a user account created for them. This is intended only for</span><br><span class="line">testing, and to make the installation go a bit smoother.</span><br><span class="line">You should remove them before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line">Remove anonymous users? (Press y|Y for Yes, any other key for No) : y  //禁止匿名访问</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from</span><br><span class="line">&apos;localhost&apos;. This ensures that someone cannot guess at</span><br><span class="line">the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : y  //不允许root远程访问</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">By default, MySQL comes with a database named &apos;test&apos; that</span><br><span class="line">anyone can access. This is also intended only for testing,</span><br><span class="line">and should be removed before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y  //删除测试数据库test</span><br><span class="line"> - Dropping test database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"> - Removing privileges on test database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">Reloading the privilege tables will ensure that all changes</span><br><span class="line">made so far will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y  重新加载授权信息</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">All done!</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">#### 常用命令</span><br><span class="line">1、开启/关闭mysql服务</span><br></pre></td></tr></table></figure>

<p>service mysqld stop/restart</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2、访问mysql数据库</span><br></pre></td></tr></table></figure>

<p>mysql -uroot -p[password]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3、显示数据库列表</span><br></pre></td></tr></table></figure>

<p>show databases;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4、选择数据库</span><br></pre></td></tr></table></figure>

<p>use databases;    #数据库名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5、显示表</span><br></pre></td></tr></table></figure>

<p>show tables;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6、显示表结构</span><br></pre></td></tr></table></figure>

<p>describe table;     #表名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7、新建/删除数据库</span><br></pre></td></tr></table></figure>

<p>create database 库名;<br>drop database 库名;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8、建表</span><br></pre></td></tr></table></figure>

<p>##demo##<br>CREATE TABLE user_info(<br>    -&gt; id varchar(30) NOT NULL,<br>    -&gt; user_name varchar(10),<br>    -&gt; password varchar(10),<br>    -&gt; PRIMARY KEY ( <code>id</code> )<br>    -&gt; );</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9、删除表</span><br></pre></td></tr></table></figure>

<p>drop table 表名;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10、清空表中数据</span><br></pre></td></tr></table></figure>

<p>delete from 表名;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11、显示表中所有数据</span><br></pre></td></tr></table></figure>

<p>select * from 表名;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12、表中添加一列  </span><br><span class="line">如果想在一个已经建好的表中添加一列：</span><br></pre></td></tr></table></figure>

<p>alter table TABLE_NAME add column NEW_COLUMN_NAME varchar(20) not null;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这条语句会向已有的表中加入新的一列，这一列在表的最后一列位置。如果我们希望添加在指定的一列：</span><br></pre></td></tr></table></figure>

<p>alter table TABLE_NAME add column NEW_COLUMN_NAME varchar(20) not null after COLUMN_NAME;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意，上面这个命令的意思是说添加新列到某一列后面。如果想添加到第一列的话：</span><br></pre></td></tr></table></figure>

<p>alter table TABLE_NAME add column NEW_COLUMN_NAME varchar(20) not null first;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13、修改一列数据长度/类型</span><br></pre></td></tr></table></figure>

<p>alter table user modify column id varchar(20);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14、删除列</span><br></pre></td></tr></table></figure>

<p>alter table user drop column id;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15、中文显示？？？</span><br></pre></td></tr></table></figure>

<p>service mysqld stop      #关闭mysql<br>whereis my.cnf          #确定配置文件位置<br>vim /etc/my.cnf          #具体情况看自己的路径</p>
<p>#[mysqld]下加以下两行<br>character_set_server=utf8<br>init_connect=’SET NAMES utf8’</p>
<p>#保存退出<br>service mysqld start</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`需要注意的是，之前在默认情况下创建的表的编码格式并不会改变！所以，如果想让在修改编码格式之前就创建好的表也修改，使用如下指令`</span><br><span class="line">`1.修改数据库的编码格式`</span><br></pre></td></tr></table></figure>

<p>alter database &lt;数据库名&gt; character set utf8;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`2.修改数据表格编码格式`</span><br></pre></td></tr></table></figure>

<p>alter table &lt;表名&gt; character set utf8;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`3.修改字段编码格式`</span><br></pre></td></tr></table></figure>

<p>alter table &lt;表名&gt; change &lt;字段名&gt; &lt;字段名&gt; &lt;类型&gt; character set utf8;<br>//demo<br>alter table user change username username varchar(20) character set utf8 not null;</p>
<pre><code>`**修改完的数据库和库里的表 并不会使原来的数据生效，而是新加入的数据才会生效。`</code></pre>]]></content>
  </entry>
  <entry>
    <title>一个移动端翻页的封装</title>
    <url>/post/likeSwiper/</url>
    <content><![CDATA[<p>想写一个移动端的h5页面<br>还不想用swiper那些工具，主要是太大，我需要的仅仅只是一个翻页功能<br>所以自己写了一个  </p>
<a id="more"></a>
<p>地址：<a href="https://github.com/MonkeyInWind/switching" target="_blank" rel="noopener">https://github.com/MonkeyInWind/switching</a><br>效果预览：<a href="https://monkeyinwind.github.io/switching/" target="_blank" rel="noopener">https://monkeyinwind.github.io/switching/</a></p>
<p>下面说一下用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/MonkeyInWind/switching.git</span><br><span class="line">cd switching</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>安装好之后</p>
<p>开发模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>打包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>先说一下功能：<br>可以根据手滑动的八个方向切换界面<br>左上、上、右上 、右  这四个方向是下一页<br>左下、下、右下、左   这四个方向是上一页<br>手滑向哪个方向  被滑走的界面就飞向哪个方向<br>做了手指滑出屏幕判断<br>切换界面会触发slide事件  可以做动画<br>配置了babel和postcss  </p>
<p>用法：<br>html结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;main_container&quot;&gt;</span><br><span class="line">    &lt;section style=&quot;background-color: red&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;div2&quot;&gt;</span><br><span class="line">            &lt;img src=&quot;./src/img/aa.png&quot; alt=&quot;&quot;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">    &lt;section style=&quot;background-color: blue&quot;&gt;&lt;/section&gt;</span><br><span class="line">    &lt;section style=&quot;background-color: yellow&quot;&gt;&lt;/section&gt;</span><br><span class="line">    &lt;section style=&quot;background-color: green&quot;&gt;&lt;/section&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Switch = new Switching(&#123;</span><br><span class="line">    target: &apos;.main_container&apos;</span><br><span class="line">&#125;);</span><br><span class="line">Switch.on(&apos;slide&apos;, function (e) &#123;</span><br><span class="line">    console.log(e);  //返回一个对象 属性包括当前界面的index   当前界面DOM节点  所有界面的DOM   滑动方向</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Linux下安装Nginx</title>
    <url>/post/installNginxInLinux/</url>
    <content><![CDATA[<h3 id="1、安装依赖"><a href="#1、安装依赖" class="headerlink" title="1、安装依赖"></a>1、安装依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="2、下载安装包"><a href="#2、下载安装包" class="headerlink" title="2、下载安装包"></a>2、下载安装包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local</span><br></pre></td></tr></table></figure>

<p><a href="http://nginx.org/download/" target="_blank" rel="noopener">http://nginx.org/download/</a><br>去上边地址找到自己想要安装的版本复制连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.9.9.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h3><p>解压到当前文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf nginx-1.9.9.tar.gz</span><br><span class="line">cd nginx-1.9.9</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>安装完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<p>会发现多了一个nginx的文件夹，nginx就被安装在这个目录下（nginx-1.9.9的文件夹和压缩包可以删了），测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd nginx/sbin</span><br><span class="line">./nginx -t</span><br></pre></td></tr></table></figure>

<p>打印如下信息， 安装完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>

<h3 id="4、常用命令"><a href="#4、常用命令" class="headerlink" title="4、常用命令"></a>4、常用命令</h3><p>安装路径 <code>/usr/local/nginx</code> 下</p>
<p>开启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./sbin/nginx</span><br></pre></td></tr></table></figure>

<p>关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./sbin/nginx -s stop (或者：nginx -s quit)</span><br></pre></td></tr></table></figure>

<p>重启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./sbin/nginx -s reload</span><br></pre></td></tr></table></figure>

<p>查看进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>视频切片转m3u8</title>
    <url>/post/videoToM3U8/</url>
    <content><![CDATA[<h3 id="1、安装ffmpeg"><a href="#1、安装ffmpeg" class="headerlink" title="1、安装ffmpeg"></a>1、安装ffmpeg</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="2-安装ffmpeg依赖"><a href="#2-安装ffmpeg依赖" class="headerlink" title="2. 安装ffmpeg依赖"></a>2. 安装ffmpeg依赖</h3><p>查看安装信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew info ffmpeg</span><br></pre></td></tr></table></figure>

<p>会显示依赖安装情况❌ 表示未安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install 需要安装的依赖</span><br></pre></td></tr></table></figure>

<h3 id="3-视频转换"><a href="#3-视频转换" class="headerlink" title="3. 视频转换"></a>3. 视频转换</h3><p>查看视频信息，只有视频编码h.264，音频编码aac的mp4视频可以转m3u8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffprobe trailer.mp4(视频文件+后缀 我的源文件就是mp4)</span><br></pre></td></tr></table></figure>

<p> 显示如下信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ffprobe version 3.4 Copyright (c) 2007-2017 the FFmpeg developers</span><br><span class="line"> built with Apple LLVM version 9.0.0 (clang-900.0.37)</span><br><span class="line">configuration: --prefix=/usr/local/Cellar/ffmpeg/3.4 --enable-shared --enable-pthreads --enable-version3 --enable-hardcoded-tables --enable-avresample --cc=clang --    host-cflags= --host-ldflags= --enable-gpl --enable-libmp3lame --enable-libx264 --enable-libxvid --enable-opencl --enable-videotoolbox --disable-lzma</span><br><span class="line">libavutil      55. 78.100 / 55. 78.100</span><br><span class="line">libavcodec     57.107.100 / 57.107.100</span><br><span class="line"> libavformat    57. 83.100 / 57. 83.100</span><br><span class="line"> libavdevice    57. 10.100 / 57. 10.100</span><br><span class="line"> libavfilter     6.107.100 /  6.107.100</span><br><span class="line"> libavresample   3.  7.  0 /  3.  7.  0</span><br><span class="line"> libswscale      4.  8.100 /  4.  8.100</span><br><span class="line"> libswresample   2.  9.100 /  2.  9.100</span><br><span class="line"> libpostproc    54.  7.100 / 54.  7.100</span><br><span class="line"> Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &apos;trailer.mp4&apos;:</span><br><span class="line"> Metadata:</span><br><span class="line">   major_brand     : mp42</span><br><span class="line">   minor_version   : 0</span><br><span class="line">   compatible_brands: mp42mp41</span><br><span class="line">   creation_time   : 2017-11-27T13:16:02.000000Z</span><br><span class="line">   Duration: 00:04:02.47, start: 0.000000, bitrate: 10342 kb/s</span><br><span class="line">   Stream #0:0(eng): Video: h264 (Main) (avc1 / 0x31637661), yuv420p(tv, bt709), 1920x1080, 10018 kb/s, 25 fps, 25 tbr, 25k tbn, 50 tbc (default)</span><br><span class="line">    Metadata:</span><br><span class="line">     creation_time   : 2017-11-27T13:16:02.000000Z</span><br><span class="line">      handler_name    : Alias Data Handler</span><br><span class="line">    encoder         : AVC Coding</span><br><span class="line">   Stream #0:1(eng): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 317 kb/s (default)</span><br><span class="line">   Metadata:</span><br><span class="line">    creation_time   : 2017-11-27T13:16:02.000000Z</span><br><span class="line">     handler_name    : Alias Data Handler</span><br></pre></td></tr></table></figure>

<p> 视频转mp4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 视频源文件.后缀 -acodec copy -vcodec copy out.mp4</span><br></pre></td></tr></table></figure>

<p>视频如果太大可以压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input_file -s 320x240 output_file</span><br></pre></td></tr></table></figure>

<p>分辨率自己看着改</p>
<p>mp4转ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -c copy -bsf:v h264_mp4toannexb output.ts</span><br></pre></td></tr></table></figure>

<p>视频切片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i output.ts -c copy -map 0 -f segment -segment_list playlist.m3u8 -segment_time 5 output%03d.ts</span><br></pre></td></tr></table></figure>

<p>命令里边的5为每段视频5秒，可自行调整，完成之后会生成一个playlist.m3u8和一堆.ts,切片到这里就完成了。</p>
<h3 id="4-页面插入视频"><a href="#4-页面插入视频" class="headerlink" title="4. 页面插入视频"></a>4. 页面插入视频</h3><p>试了两种方式<br>一种是video.js + videojs-contrib-hls.js<br>这种方式不兼容IE10-<br><a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">video.js</a><br><a href="https://github.com/videojs/videojs-contrib-hls" target="_blank" rel="noopener">videojs-contrib-hls</a></p>
<pre><code>&lt;video id=example-video width=960 height=540 class=&quot;video-js vjs-default-skin&quot; controls&gt;
    &lt;source src=&quot;./video/playlist.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt;
&lt;/video&gt;
&lt;script src=&quot;video.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;videojs.hls.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    var player = videojs(&apos;example-video&apos;);
    player.play();
&lt;/script&gt;</code></pre><p>另一种方式用ckplayer<br>官网：<a href="http://www.ckplayer.com/" target="_blank" rel="noopener">http://www.ckplayer.com/</a><br>下载之后解压找到<code>crossdomain.xml</code>和<code>ckplayer</code>文件夹放到根目录下  </p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;ckplayer/ckplayer.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;video&quot; style=&quot;width:600px;height:400px;&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    var videoObject = {
        container:&apos;#video&apos;,
        variable:&apos;player&apos;,
        autoplay:true, //强制使用ckplay做播放器
        video:&apos;./video/playlist.m3u8&apos;
    };
    var player=new ckplayer(videoObject);
&lt;script&gt;</code></pre><p>视频会带ckplay的水印，但是不影响。</p>
]]></content>
  </entry>
  <entry>
    <title>用了react-router刷新404 nginx配置</title>
    <url>/post/reactRouterNginx/</url>
    <content><![CDATA[<p>react项目用了react-router<br>发现只有首页可以访问，在子页面刷新时not found  </p>
<a id="more"></a>
<p>nginx配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">  server_name xxx.xxxxxxx.com;  </span><br><span class="line">  location / &#123;  </span><br><span class="line">    proxy_pass http://11.11.11.11:1111/; (node服务端口)  </span><br><span class="line">    root html;  </span><br><span class="line">    index index.html index.htm;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为他会根据url去找相应路径下的html<br>但是react只有一个index.html入口<br>需要改成静态路径并且加一行 <code>try_files $uri /index.html;</code><br>无论uri是否变化<br>都返回index.html  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">  server_name xxx.xxxxxx.com;  </span><br><span class="line">  location / &#123;  </span><br><span class="line">    root /xxx/xxx/xxx/www/build;  </span><br><span class="line">    try_files $uri /index.html;  </span><br><span class="line">  &#125;  </span><br><span class="line">  location ^~ /api/ &#123;  </span><br><span class="line">    proxy_pass http://11.11.11.11:1111/;(服务端接口做代理)  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>flutter for web</title>
    <url>/post/flutterForWeb/</url>
    <content><![CDATA[<p>谷歌开发者大会上宣布flutter1.9正式发布，并且flutter_web已经合到dev合master。<br>我们来体验一下。  </p>
<a id="more"></a>
<p>首先切换到master并升级flutter到最新版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter channel master</span><br><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure>

<p>安装<code>webdev</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter pub global activate webdev</span><br></pre></td></tr></table></figure>

<p>这里需要注意一下，安装之后看提示还要添加环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Installed executable webdev.</span><br><span class="line">Warning: Pub installs executables into $HOME/.pub-cache/bin, which is not on your path.</span><br><span class="line">You can fix that by adding this to your shell&apos;s config file (.bashrc, .bash_profile, etc.):</span><br><span class="line"></span><br><span class="line">  export PATH=&quot;$PATH&quot;:&quot;$HOME/.pub-cache/bin&quot;</span><br><span class="line"></span><br><span class="line">Activated webdev 2.5.1.</span><br></pre></td></tr></table></figure>

<p>打开<code>~ &gt; .bash_profile</code>把<code>export PATH=&quot;$PATH&quot;:&quot;$HOME/.pub-cache/bin&quot;</code>添加进去，然后更新环境变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>到这<code>webdev</code>就完事了，命令行敲<code>webdev</code>测试一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webdev</span><br><span class="line">/Users/xxx/.pub-cache/bin/webdev: line 7: dart: command not found</span><br></pre></td></tr></table></figure>

<p>惊不惊喜，意不意外，这是因为<code>dart</code>没有添加环境变量。<br>在<code>.bash_profile</code>中添加dart环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export DART_HOME=/Users/xxx/sdk/flutter/bin/cache/dart-sdk/bin</span><br><span class="line">export PATH=$&#123;DART_HOME&#125;:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure>

<p>刷新环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>重新试一下<code>webdev</code>如果显示如下，说明没有问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A tool to develop Dart web projects.</span><br><span class="line"></span><br><span class="line">Usage: webdev &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">Global options:</span><br><span class="line">-h, --help       Print this usage information.</span><br><span class="line">    --version    Prints the version of webdev.</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line">  build   Run builders to build a package.</span><br><span class="line">  help    Display help information for webdev.</span><br><span class="line">  serve   Run a local web development server and a file system watcher that rebuilds on changes.</span><br><span class="line"></span><br><span class="line">Run &quot;webdev help &lt;command&gt;&quot; for more information about a command.</span><br></pre></td></tr></table></figure>

<p>这里需要注意一下，如果没有用<code>flutter</code>自带的<code>dart-sdk</code>而是单独安装，这里可能会因为dart版本与flutter版本不匹配而出现如下提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Can&apos;t load Kernel binary: Invalid kernel binary format version.</span><br><span class="line">No active package webdev.</span><br></pre></td></tr></table></figure>

<p>出现这种情况把dart卸载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew uninstall dart</span><br></pre></td></tr></table></figure>

<p>然后如前边所述将flutter内置的dart-sdk添加到环境变量就可以了。<br>启用<code>flutter_web</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter config --enable-web</span><br></pre></td></tr></table></figure>

<p>出现如下提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting &quot;enable-web&quot; value to &quot;true&quot;.</span><br></pre></td></tr></table></figure>

<p>接下来创建一个flutter项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter create myapp</span><br><span class="line">cd myapp</span><br></pre></td></tr></table></figure>

<p>可以看见目录下多了一个<code>web</code>文件夹里边是一个<code>index.html</code>，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;myapp&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script src=&quot;main.dart.js&quot; type=&quot;application/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>从这里可以看见，最终也是编译成js文件。<br>先看一下已连接的设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  myapp flutter devices</span><br><span class="line">3 connected devices:</span><br><span class="line"></span><br><span class="line">macOS  • macOS  • darwin-x64     • Mac OS X 10.14.5 18F132</span><br><span class="line">Chrome • chrome • web-javascript • Google Chrome 76.0.3809.132</span><br><span class="line">Server • web    • web-javascript • Flutter Tools</span><br></pre></td></tr></table></figure>

<p>这里合之前相比多了<code>Chrome</code>和<code>Server</code></p>
<p>在chrome里跑一下项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter run -d chrome</span><br></pre></td></tr></table></figure>

<p>效果如下，一个熟悉的页面。<br><img src="1.png" alt="image.png"><br>可以看见大多数都是自定义标签，当然也不全是自定义，比如中间那一行文本和数字就是<code>p</code>标签，关于渲染<code>flutter</code>用了<a href="https://developers.google.com/web/updates/2018/01/paintapi" target="_blank" rel="noopener">CSS Paint</a>（能不能打开看缘分），就是用css画图，挺有意思的api。<br>点<code>sources</code>，然后<code>command+o</code><br><img src="2.png" alt="image.png"><br>可以看见这里并不是js文件，而是dart文件。<br>选择<code>main.dart</code>，看到的就是<code>main.dart</code>的源码。<br>接下来说一下调试，直接用chrome的开发者工具查找DOM是比较困难的，这个时候需要<code>android Studio</code>，在<code>android Studio</code>中打开<code>myapp</code>，设备选择<code>chrome(web)</code>，点绿色的三角跑起来<br><img src="3.png" alt="image.png"><br>在<code>View &gt; Tool Windows</code>下选择<code>Flutter Inspector</code><br><img src="4.png" alt="image.png"><br>打开之后是这个样子<br><img src="5.png" alt="image.png"><br>可以看到不知道多少个层级<br><img src="6.png" alt="image.png"><br>这个按钮可以在页面上显示<code>widget</code>的边界<br><img src="7.png" alt="image.png"><br>这个准星一样的按钮相当于浏览器的审查元素，点击之后页面左下角会出现一个放大镜，想要重新在页面上选择元素需要点击放大镜，也可以在<code>Inspector</code>之中直接选择，页面上对应的元素会高亮。<br>这里再说一下另一种方式，chrome内置了<code>Dart DevTools</code><br>项目跑起来之后点下边这个按钮<br><img src="8.png" alt="image.png"><br>chrome会弹出个新窗口<br><img src="9.png" alt="image.png"><br>和<code>Flutter Insector</code>类似，但是更好用一点。</p>
<p>关于<code>dart</code>文件的调试，和js一样可以打断点<br><img src="10.png" alt="image.png"></p>
<p>接下来是打包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  myapp flutter build web</span><br><span class="line">Compiling lib/main.dart for the Web...                             26.4s</span><br></pre></td></tr></table></figure>

<p>build结束后看一下<code>build &gt; web</code>目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  web ls</span><br><span class="line">assets           index.html       main.dart.js     main.dart.js.map</span><br></pre></td></tr></table></figure>

<p><code>dart</code>被编译成了js</p>
]]></content>
  </entry>
</search>
